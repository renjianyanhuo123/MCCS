# StaticControl 临时监控功能说明

## 功能概述

为了避免在数据采集循环中执行复杂的判断逻辑而影响采集效率，我们实现了基于 Reactive Extensions 的临时监控机制。

## 核心设计

### 架构分离

```
┌─────────────────────────────────────┐
│  数据采集循环 (高优先级线程)          │
│  - 只负责快速采集                    │
│  - 不包含任何判断逻辑                 │
│  - 保持微秒级响应                    │
└──────────────┬──────────────────────┘
               │
               ▼
         数据流 (_dataSubject)
               │
    ┌──────────┴──────────────────┐
    │                             │
    ▼                             ▼
数据存储/展示              临时监控订阅
                          (独立线程异步处理)
                          - 滑动窗口缓冲
                          - 目标条件判断
                          - 自动清理
```

### 工作流程

1. **点击应用 StaticControl** → 启动临时监控订阅
2. **数据流自动处理** → 连续6条数据判断
3. **达到目标或超时** → 自动停止并清理订阅
4. **没有命令执行** → 不创建任何监控，节省资源

## 使用方式

### 自动启动（推荐）

在调用 `StaticControl` 时会自动启动临时监控：

```csharp
public override bool StaticControl(StaticControlParams controlParams)
{
    // ... 硬件控制逻辑 ...

    if (result == OP_SUCCESSFUL)
    {
        // 自动启动临时监控
        StartStaticControlMonitoring(
            controlParams,
            allowedErrorPercent: 0.02f,  // 允许误差2%
            timeoutSeconds: 300           // 超时300秒
        );
    }
}
```

### 手动控制（可选）

```csharp
// 停止指定设备的监控
StopMonitoring(deviceId);

// 停止所有监控
StopAllMonitorings();
```

## 核心参数

### allowedErrorPercent（允许误差百分比）

- **默认值**: 0.02 (2%)
- **说明**: 当前值与目标值的误差在此范围内认为达到目标
- **示例**:
  - 目标值 100，误差 2% → 允许范围 [98, 102]
  - 目标值 -50，误差 2% → 允许范围 [-51, -49]

### timeoutSeconds（超时时间）

- **默认值**: 300秒
- **说明**: 如果在指定时间内未达到目标，触发超时
- **触发结果**: 状态变为 `CommandExecuteStatusEnum.Timeout`

## 判断逻辑

### 连续6条数据检测

使用 Rx 的 `Buffer(6, 1)` 操作符实现滑动窗口：

```
数据流: [1] [2] [3] [4] [5] [6] [7] [8] ...
窗口1:  [1] [2] [3] [4] [5] [6]         → 检测
窗口2:      [2] [3] [4] [5] [6] [7]     → 检测
窗口3:          [3] [4] [5] [6] [7] [8] → 检测
...
```

### 控制模式匹配

| 控制模式 | 监控信号 | 说明 |
|---------|---------|------|
| `CTRLMODE_LoadN` | Net_AD_N | 力控制 - 监控力信号 |
| `CTRLMODE_LoadS` | Net_AD_S | 位移控制 - 监控位移信号 |
| `CTRLMODE_LoadSVNP` | Net_AD_N | 位移速度+力目标 - 监控力信号 |
| `CTRLMODE_LoadNVSP` | Net_AD_S | 力速度+位移目标 - 监控位移信号 |

## 状态变化

### 执行流程

```
NoExecute → Executing → ExecuttionCompleted
                    ↓
                  Timeout / Failed
```

### 状态说明

- **Executing**: 命令执行中，监控已启动
- **ExecuttionCompleted**: 连续6条数据达到目标
- **Timeout**: 超过指定时间未达到目标
- **Failed**: 监控过程中发生错误

## 性能优势

### 零影响数据采集

✅ **采集循环保持最高效率**
- 数据采集使用 `ThreadPriority.Highest` 高优先级线程
- 采集循环只调用 `AcquireReading()`，无任何判断逻辑
- 保持微秒级精确定时

✅ **判断逻辑异步处理**
- 监控订阅在独立线程上运行
- 使用 `ObserveOn(TaskPoolScheduler.Default)` 异步调度
- 毫秒级延迟，不影响采集

✅ **资源按需分配**
- 只在需要时创建订阅
- 达到目标或超时后自动清理
- 没有命令执行时零开销

### 示例对比

#### ❌ 错误做法（影响采集）

```csharp
private DataPoint AcquireReading()
{
    var data = ReadHardware();

    // ❌ 在采集循环中判断 - 影响采集效率！
    if (CheckTargetReached(data)) {
        UpdateStatus();
    }

    return data;
}
```

#### ✅ 正确做法（本实现）

```csharp
private DataPoint AcquireReading()
{
    // ✅ 只负责采集，不包含任何判断
    return ReadHardware();
}

// 判断逻辑在独立的订阅流中处理
IndividualDataStream
    .Buffer(6, 1)
    .Subscribe(buffer => CheckAndUpdate(buffer));
```

## 扩展性

### 添加新的监控逻辑

可以轻松添加其他类型的监控：

```csharp
protected void StartDynamicControlMonitoring(DynamicControlParams controlParams)
{
    var subscription = IndividualDataStream
        .Buffer(10, 1)  // 不同的窗口大小
        .Select(buffer => CheckDynamicCondition(buffer, controlParams))
        .Subscribe(/* ... */);

    _activeMonitorings.TryAdd(controlParams.DeviceId, subscription);
}
```

### 多个监控并行运行

每个设备的监控是独立的，互不干扰：

```csharp
// 设备1：静态控制监控
StartStaticControlMonitoring(controlParams1);

// 设备2：静态控制监控
StartStaticControlMonitoring(controlParams2);

// 两个监控同时运行，完全独立
```

## 注意事项

1. **自动清理**: 监控订阅在达到目标、超时或错误时会自动清理，无需手动管理
2. **重复调用**: 对同一设备多次调用会自动停止之前的监控，启动新的监控
3. **资源释放**: Dispose 时会自动清理所有活跃的监控订阅
4. **线程安全**: 使用 `ConcurrentDictionary` 确保线程安全

## 调试

### 订阅状态监控

可以通过 `CommandStatusStream` 观察状态变化：

```csharp
device.CommandStatusStream.Subscribe(evt =>
{
    Console.WriteLine($"设备 {evt.DeviceId}: {evt.Status}");
});
```

### 活跃监控数量

```csharp
var activeCount = _activeMonitorings.Count;
Console.WriteLine($"当前活跃监控数: {activeCount}");
```
