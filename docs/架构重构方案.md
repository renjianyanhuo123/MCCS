# MCCS æ¶æ„é‡æ„æ–¹æ¡ˆ

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

æœ¬æ–‡æ¡£é’ˆå¯¹ MCCSï¼ˆåˆ†å¸ƒå¼å¤šé€šé“æ§åˆ¶ç³»ç»Ÿï¼‰çš„æ•°æ®é‡‡é›†å’Œæ§åˆ¶å‘½ä»¤å‘é€æ¨¡å—æå‡ºå…¨é¢çš„æ¶æ„é‡æ„æ–¹æ¡ˆã€‚ç°æœ‰æ¶æ„å­˜åœ¨ç´§è€¦åˆã€æ‰©å±•æ€§å·®ã€æ€§èƒ½ç“¶é¢ˆç­‰é—®é¢˜ã€‚æ–°æ¶æ„é‡‡ç”¨**åˆ†å±‚è®¾è®¡ã€æ’ä»¶åŒ–ã€å‘½ä»¤æ¨¡å¼ã€å“åº”å¼ç¼–ç¨‹**ç­‰ç°ä»£è½¯ä»¶å·¥ç¨‹å®è·µï¼Œå®ç°é«˜æ€§èƒ½ã€é«˜å¯é æ€§ã€æ˜“æ‰©å±•çš„ç³»ç»Ÿæ¶æ„ã€‚

### æ ¸å¿ƒæ”¹è¿›
- âš¡ **æ€§èƒ½æå‡**: ä¼˜åŒ–çš„å†…å­˜ç®¡ç†ã€èƒŒå‹æ§åˆ¶ã€å¹¶è¡Œå¤„ç†
- ğŸ”Œ **å¯æ‰©å±•æ€§**: æ’ä»¶åŒ–æ¶æ„ã€ç­–ç•¥æ¨¡å¼ã€ä¾èµ–æ³¨å…¥
- ğŸ›¡ï¸ **å¯é æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†ã€é‡è¯•æœºåˆ¶ã€å¥åº·ç›‘æ§
- ğŸ“Š **å¯è§‚æµ‹æ€§**: æŒ‡æ ‡é‡‡é›†ã€åˆ†å¸ƒå¼è¿½è¸ªã€ç»“æ„åŒ–æ—¥å¿—

---

## ğŸ” ç°æœ‰æ¶æ„åˆ†æ

### å½“å‰æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           UI Layer (WPF ViewModels)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        ControllerService (Singleton)            â”‚
â”‚  - DLL åˆå§‹åŒ–                                   â”‚
â”‚  - æ§åˆ¶å™¨ç®¡ç†                                   â”‚
â”‚  - å‘½ä»¤è½¬å‘                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ControllerHardwareDeviceBase (Abstract)       â”‚
â”‚   â”œâ”€ BwControllerHardwareDevice (Real)          â”‚
â”‚   â””â”€ MockControllerHardwareDevice (Mock)        â”‚
â”‚                                                  â”‚
â”‚  - æ•°æ®é‡‡é›†å¾ªç¯ (Observable.Generate)           â”‚
â”‚  - æ§åˆ¶å‘½ä»¤ç›´æ¥è°ƒç”¨ DLL                         â”‚
â”‚  - å‘½ä»¤çŠ¶æ€è¿½è¸ª                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         POPNETCtrl01.dll (P/Invoke)             â”‚
â”‚         Native C++ Hardware Driver              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ
- **.NET 8.0** - è¿è¡Œæ—¶
- **System.Reactive (Rx.NET)** - å“åº”å¼ç¼–ç¨‹
- **WPF + Prism** - UI æ¡†æ¶
- **DryIoc** - ä¾èµ–æ³¨å…¥
- **Serilog** - æ—¥å¿—
- **FreeSql + SQLite** - æ•°æ®æŒä¹…åŒ–

---

## âš ï¸ è¯†åˆ«çš„å…³é”®é—®é¢˜

### 1. æ•°æ®é‡‡é›†å±‚é—®é¢˜

#### 1.1 å†…å­˜ç®¡ç†ç¼ºé™·

**é—®é¢˜ä»£ç ** (`BwControllerHardwareDevice.cs:245-246`):
```csharp
if(_singleBuffer != IntPtr.Zero)  // âŒ BUG: åº”è¯¥æ˜¯ == è€Œé !=
    _singleBuffer = BufferPool.Rent();
```

**å½±å“**:
- âŒ åˆæ¬¡è°ƒç”¨æ—¶ `_singleBuffer` ä¸º `IntPtr.Zero`ï¼Œä¸ä¼šç§Ÿç”¨ç¼“å†²åŒº
- âŒ åç»­è°ƒç”¨ä¼šé‡å¤ç§Ÿç”¨ä½†ä»ä¸å½’è¿˜ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼
- âŒ ç¨‹åºè¿è¡Œæ—¶å†…å­˜æŒç»­å¢é•¿

**æ ¹æœ¬åŸå› **: ç¼ºä¹ RAII (èµ„æºè·å–å³åˆå§‹åŒ–) æ¨¡å¼ï¼Œæ‰‹åŠ¨ç®¡ç†éæ‰˜ç®¡å†…å­˜å®¹æ˜“å‡ºé”™

#### 1.2 èŒè´£æ··ä¹±

**é—®é¢˜**: `AcquireReading()` æ–¹æ³•æ‰¿æ‹…äº†å¤šä¸ªèŒè´£ï¼š
```csharp
private DataPoint AcquireReading()
{
    // 1ï¸âƒ£ ä»ç¡¬ä»¶è¯»å–åŸå§‹æ•°æ®
    POPNetCtrl.NetCtrl01_GetAD_HDataCount(...);
    POPNetCtrl.NetCtrl01_GetAD_HInfo(...);

    // 2ï¸âƒ£ å†…å­˜ç®¡ç†
    _singleBuffer = BufferPool.Rent();
    Marshal.PtrToStructure<TNet_ADHInfo>(...);

    // 3ï¸âƒ£ æ•°æ®è½¬æ¢
    StructDataToCollectModel(tempValue);

    // 4ï¸âƒ£ è´¨é‡åˆ¤æ–­
    DataQuality = DataQuality.Good/Bad
}
```

**è¿ååŸåˆ™**: å•ä¸€èŒè´£åŸåˆ™ (SRP)

#### 1.3 ç¼ºä¹èƒŒå‹æ§åˆ¶

**é—®é¢˜**:
```csharp
_dataSubject = new ReplaySubject<DataPoint>(bufferSize: 1000);
```

- âŒ å›ºå®šçš„1000ç¼“å†²åŒºï¼Œæ— æ³•åº”å¯¹é«˜é€Ÿé‡‡é›† (å¦‚10kHzé‡‡æ ·ç‡)
- âŒ å½“æ¶ˆè´¹è€…å¤„ç†æ…¢æ—¶ï¼Œæ•°æ®ä¸¢å¤±ä½†æ— å‘Šè­¦
- âŒ æ²¡æœ‰æµæ§ç­–ç•¥ (throttle, buffer, sample)

**åœºæ™¯**: å¦‚æœé‡‡æ ·ç‡ä¸º 10kHzï¼Œç¼“å†²åŒºä»…èƒ½å®¹çº³ 0.1 ç§’æ•°æ®

#### 1.4 é‡‡é›†ç­–ç•¥ä¸çµæ´»

**ç¡¬ç¼–ç **:
```csharp
_sampleRate = configuration.Signals.Max(s => s.SampleRate); // å›ºå®šé‡‡æ ·ç‡
TimeSpan.FromTicks(Stopwatch.Frequency / _sampleRate);     // å›ºå®šæ—¶é—´é—´éš”
```

**é™åˆ¶**:
- âŒ æ— æ³•åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡ï¼ˆå¦‚ç©ºé—²æ—¶é™ä½ï¼Œæµ‹è¯•æ—¶æé«˜ï¼‰
- âŒ æ‰€æœ‰é€šé“ä½¿ç”¨ç›¸åŒé‡‡æ ·ç‡ï¼Œæµªè´¹èµ„æº
- âŒ æ— æ³•å®ç°è§¦å‘é‡‡é›†ã€æ¡ä»¶é‡‡é›†ç­‰é«˜çº§æ¨¡å¼

#### 1.5 é”™è¯¯å¤„ç†ç²—ç³™

```csharp
_ =>
{
    // å‘é€é”™è¯¯æ•°æ®ç‚¹è€Œä¸æ˜¯åœæ­¢æµ
    var errorReading = new DataPoint
    {
        Value = double.NaN,
        DataQuality = DataQuality.Bad
    };
    _dataSubject.OnNext(errorReading);
}
```

**é—®é¢˜**:
- âŒ æ‰€æœ‰å¼‚å¸¸éƒ½è¢«åæ‰ï¼Œä¸åŒºåˆ†ç±»å‹
- âŒ æ²¡æœ‰é‡è¯•æœºåˆ¶
- âŒ æ²¡æœ‰é”™è¯¯è®¡æ•°å’Œå‘Šè­¦
- âŒ æ— æ³•è¯Šæ–­ç¡¬ä»¶æ•…éšœ

---

### 2. æ§åˆ¶å‘½ä»¤å±‚é—®é¢˜

#### 2.1 åŒæ­¥é˜»å¡è°ƒç”¨

**æ‰€æœ‰å‘½ä»¤éƒ½æ˜¯åŒæ­¥çš„**:
```csharp
public override bool StaticControl(StaticControlParams controlParams)
{
    // âŒ é˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ° DLL è°ƒç”¨è¿”å›
    var result = POPNetCtrl.NetCtrl01_S_SetCtrlMod(
        _deviceHandle,
        (uint)controlParams.StaticLoadControl,
        controlParams.Speed,
        controlParams.TargetValue
    );
    return result == AddressContanst.OP_SUCCESSFUL;
}
```

**å½±å“**:
- âŒ UI çº¿ç¨‹å¯èƒ½è¢«é•¿æ—¶é—´é˜»å¡ï¼ˆå¦‚æœåœ¨ UI çº¿ç¨‹è°ƒç”¨ï¼‰
- âŒ å‘½ä»¤æ‰§è¡ŒæœŸé—´æ— æ³•å–æ¶ˆ
- âŒ å¤šä¸ªå‘½ä»¤ä¸²è¡Œæ‰§è¡Œï¼Œååé‡ä½

#### 2.2 å‘½ä»¤çŠ¶æ€è¿½è¸ªä¸å®Œå–„

**é—®é¢˜**:
```csharp
// å‘½ä»¤å‘é€æ—¶è®¾ç½®ä¸º Executing
UpdateDeviceCommandStatus(deviceId, context, CommandExecuteStatusEnum.Executing);

// âŒ ä½†ä»æœªæ›´æ–°ä¸º Completed æˆ– Failed
// âŒ æ²¡æœ‰è¶…æ—¶æ£€æµ‹
// âŒ æ— æ³•æŸ¥è¯¢å‘½ä»¤çœŸå®æ‰§è¡Œè¿›åº¦
```

**å‘½ä»¤ç”Ÿå‘½å‘¨æœŸä¸å®Œæ•´**:
```
Created â”€â”€> Executing â”€â”€> â“ (ç¼ºå¤±: Completed/Failed/Timeout/Cancelled)
```

#### 2.3 æ— å¹¶å‘æ§åˆ¶

**é—®é¢˜åœºæ™¯**:
```csharp
// çº¿ç¨‹ 1
ManualControl(deviceId: 1, speed: 10.0);

// çº¿ç¨‹ 2 (åŒæ—¶)
StaticControl(new StaticControlParams { DeviceId = 1, ... });
```

**åæœ**:
- âŒ ä¸¤ä¸ªå‘½ä»¤å¯èƒ½åŒæ—¶å‘é€åˆ°ç¡¬ä»¶ï¼Œå¯¼è‡´ä¸å¯é¢„æµ‹è¡Œä¸º
- âŒ æ²¡æœ‰äº’æ–¥é”ä¿æŠ¤ä¸´ç•ŒåŒº
- âŒ `ControlState` çš„è¯»å†™å­˜åœ¨ç«æ€æ¡ä»¶

#### 2.4 ç¼ºä¹å‘½ä»¤é˜Ÿåˆ—å’Œä¼˜å…ˆçº§

**ç°çŠ¶**: å‘½ä»¤ç«‹å³æ‰§è¡Œï¼Œæ— æ’é˜Ÿæœºåˆ¶

**éœ€æ±‚åœºæ™¯**:
- ğŸš¨ **ç´§æ€¥åœæ­¢å‘½ä»¤**åº”ä¼˜å…ˆäºå¸¸è§„å‘½ä»¤
- ğŸ“‹ **æ‰¹é‡å‘½ä»¤**éœ€è¦æŒ‰é¡ºåºæ‰§è¡Œ
- â±ï¸ **å®šæ—¶å‘½ä»¤**éœ€è¦å»¶è¿Ÿæ‰§è¡Œ
- ğŸ”„ **å‘¨æœŸå‘½ä»¤**éœ€è¦é‡å¤æ‰§è¡Œ

#### 2.5 æ— é‡è¯•å’Œé™çº§ç­–ç•¥

**å½“å‰å®ç°**:
```csharp
var result = POPNetCtrl.NetCtrl01_S_SetCtrlMod(...);
return result == AddressContanst.OP_SUCCESSFUL; // âŒ å¤±è´¥ç›´æ¥è¿”å› false
```

**é—®é¢˜**:
- âŒ ä¸´æ—¶æ€§ç¡¬ä»¶æ•…éšœï¼ˆå¦‚ç¬æ—¶é€šä¿¡é”™è¯¯ï¼‰å¯¼è‡´å‘½ä»¤æ°¸ä¹…å¤±è´¥
- âŒ æ²¡æœ‰æŒ‡æ•°é€€é¿é‡è¯•
- âŒ æ²¡æœ‰é™çº§æ¨¡å¼ï¼ˆå¦‚é™ä½ç²¾åº¦ã€ä½¿ç”¨å¤‡ç”¨æ§åˆ¶å™¨ï¼‰

---

### 3. æœåŠ¡å±‚é—®é¢˜

#### 3.1 ControllerService èŒè´£è¿‡é‡

**å•ä¸ªç±»æ‰¿æ‹…è¿‡å¤šèŒè´£**:
```csharp
public sealed class ControllerService : IControllerService
{
    // 1ï¸âƒ£ DLL ç”Ÿå‘½å‘¨æœŸç®¡ç†
    public bool InitializeDll(bool isMock = false) { ... }

    // 2ï¸âƒ£ æ§åˆ¶å™¨é›†åˆç®¡ç†
    private readonly List<ControllerHardwareDeviceBase> _controllers = [];

    // 3ï¸âƒ£ å‘½ä»¤è½¬å‘
    public bool ManualControl(...) => GetControllerInfo(...).ManualControl(...);

    // 4ï¸âƒ£ å…¨å±€æ“ä½œ
    public void StartAllControllers() { ... }
}
```

**è¿ååŸåˆ™**: å•ä¸€èŒè´£åŸåˆ™ã€æ¥å£éš”ç¦»åŸåˆ™

#### 3.2 ç¼ºä¹ä¸­é—´æŠ½è±¡å±‚

**ç°çŠ¶**: UI â†’ ControllerService â†’ HardwareDevice â†’ DLL

**ç¼ºå¤±çš„æŠ½è±¡**:
- ğŸ”„ **å‘½ä»¤å±‚**: ç»Ÿä¸€çš„å‘½ä»¤æ¥å£å’Œç”Ÿå‘½å‘¨æœŸ
- ğŸ“Š **ç­–ç•¥å±‚**: å¯æ’æ‹”çš„æ§åˆ¶ç®—æ³•
- ğŸ”Œ **é€‚é…å™¨å±‚**: ç»Ÿä¸€çš„ç¡¬ä»¶æ¥å£
- ğŸ¯ **ç¼–æ’å±‚**: å·¥ä½œæµå’ŒçŠ¶æ€æœº

---

### 4. æ¶æ„é—®é¢˜

#### 4.1 æ‰©å±•æ€§å·®

**æ·»åŠ æ–°æ§åˆ¶æ¨¡å¼çš„æˆæœ¬é«˜**:

éœ€è¦ä¿®æ”¹çš„ä½ç½®ï¼š
1. `SystemControlState` æšä¸¾ (å¢åŠ æ–°çŠ¶æ€)
2. `ControllerHardwareDeviceBase` (æ·»åŠ æŠ½è±¡æ–¹æ³•)
3. `BwControllerHardwareDevice` (å®ç°å…·ä½“é€»è¾‘)
4. `MockControllerHardwareDevice` (å®ç° Mock é€»è¾‘)
5. `IControllerService` æ¥å£ (æ·»åŠ æ–°æ–¹æ³•)
6. `ControllerService` (å®ç°è½¬å‘)
7. æ‰€æœ‰è°ƒç”¨æ–¹ï¼ˆViewModelã€å·¥ä½œæµç­‰ï¼‰

**è¿ååŸåˆ™**: å¼€é—­åŸåˆ™ï¼ˆå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼‰

#### 4.2 æµ‹è¯•å›°éš¾

**é—®é¢˜**:
- Mock å®ç°ä¸çœŸå®å®ç°å·®å¼‚å¤§ï¼Œé›†æˆæµ‹è¯•ä¸å¯é 
- ç¼ºä¹æ¥å£éš”ç¦»ï¼Œéš¾ä»¥ Stub/Mock ä¾èµ–
- ç¡¬ä»¶å±‚å’Œä¸šåŠ¡é€»è¾‘æ··åˆï¼Œæ— æ³•ç‹¬ç«‹æµ‹è¯•

#### 4.3 é…ç½®åˆ†æ•£

**ç¡¬ç¼–ç é…ç½®**:
```csharp
bufferSize: 1000                     // æ•°æ®ç¼“å†²åŒºå¤§å°
TimeoutMs = 5000                     // å‘½ä»¤è¶…æ—¶æ—¶é—´
RequiredStableCount = 6              // ç¨³å®šæ€§æ£€æµ‹æ¬¡æ•°
PositionTolerance = 0.5f             // ä½ç½®å®¹å·®
Priority = ThreadPriority.Highest    // çº¿ç¨‹ä¼˜å…ˆçº§
```

**é—®é¢˜**: æ— æ³•æ ¹æ®ç¯å¢ƒï¼ˆå¼€å‘/æµ‹è¯•/ç”Ÿäº§ï¼‰è°ƒæ•´å‚æ•°

---

## ğŸ—ï¸ æ–°æ¶æ„è®¾è®¡

### æ¶æ„æ„¿æ™¯

**è®¾è®¡åŸåˆ™**:
1. **åˆ†å±‚æ¶æ„**: æ¸…æ™°çš„åˆ†å±‚ï¼Œæ¯å±‚èŒè´£å•ä¸€
2. **ä¾èµ–å€’ç½®**: é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡
3. **å¼€é—­åŸåˆ™**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
4. **æ¥å£éš”ç¦»**: å®¢æˆ·ç«¯ä¸åº”ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£
5. **ç»„åˆä¼˜äºç»§æ‰¿**: ä½¿ç”¨ç»„åˆæ„å»ºçµæ´»çš„ç³»ç»Ÿ

**æ¶æ„é£æ ¼**:
- **å…­è¾¹å½¢æ¶æ„ (Hexagonal Architecture)**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸å¤–éƒ¨ä¾èµ–éš”ç¦»
- **CQRS (è½»é‡çº§)**: è¯»å†™åˆ†ç¦»ï¼Œä¼˜åŒ–æŸ¥è¯¢å’Œå‘½ä»¤è·¯å¾„
- **äº‹ä»¶é©±åŠ¨**: ä½¿ç”¨äº‹ä»¶æ€»çº¿è§£è€¦ç»„ä»¶

### æ–°æ¶æ„æ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Presentation Layer                          â”‚
â”‚                   (WPF ViewModels + Views)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚      Event Bus             â”‚
                â”‚  (è§‚å¯Ÿè€…ã€è§£è€¦é€šä¿¡)        â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  ControllerOrchestrator (ç¼–æ’å™¨)                          â”‚  â”‚
â”‚  â”‚  - åè°ƒå¤šä¸ªæ§åˆ¶å™¨çš„æ“ä½œ                                   â”‚  â”‚
â”‚  â”‚  - ç®¡ç†å…¨å±€çŠ¶æ€å’Œå·¥ä½œæµ                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Domain Layer                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            Command Execution Pipeline                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚   â”‚
â”‚  â”‚  â”‚ Command  â”‚â”€â–¶â”‚ Command  â”‚â”€â–¶â”‚  Command   â”‚             â”‚   â”‚
â”‚  â”‚  â”‚ Builder  â”‚  â”‚  Queue   â”‚  â”‚  Executor  â”‚             â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚   â”‚
â”‚  â”‚       â”‚              â”‚               â”‚                    â”‚   â”‚
â”‚  â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚   â”‚
â”‚  â”‚              CommandBus (CQRS)                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         Data Acquisition Pipeline                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ Hardware â”‚â”€â–¶â”‚  Data    â”‚â”€â–¶â”‚Backpress.â”‚â”€â–¶â”‚ Publish â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Sampler  â”‚  â”‚Transform â”‚  â”‚ Strategy â”‚  â”‚  Stream â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚             Control Strategy Layer                        â”‚   â”‚
â”‚  â”‚  (ç­–ç•¥æ¨¡å¼: Static, Dynamic, Manual, PID, Fuzzy...)       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Infrastructure Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Hardware Adapter â”‚  â”‚ Memory Pool Mgr  â”‚  â”‚Configuration â”‚   â”‚
â”‚  â”‚     (æŠ½è±¡å±‚)     â”‚  â”‚  (ä¼˜åŒ–çš„æ± åŒ–)    â”‚  â”‚   Manager    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Health Monitor   â”‚  â”‚ Metrics Collectorâ”‚  â”‚  Structured  â”‚   â”‚
â”‚  â”‚  (å¥åº·æ£€æŸ¥)      â”‚  â”‚   (æŒ‡æ ‡è¿½è¸ª)     â”‚  â”‚   Logging    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚  â”‚Connection Pool   â”‚  â”‚  Circuit Breaker â”‚                     â”‚
â”‚  â”‚  (è¿æ¥å¤ç”¨)      â”‚  â”‚    (ç†”æ–­å™¨)      â”‚                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Hardware Layer                                â”‚
â”‚               POPNETCtrl01.dll (P/Invoke)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è¯¦ç»†è®¾è®¡

### 1. æ•°æ®é‡‡é›†ç®¡é“ (Data Acquisition Pipeline)

#### 1.1 é‡‡é›†ç­–ç•¥æ¥å£

```csharp
/// <summary>
/// æ•°æ®é‡‡é›†ç­–ç•¥æ¥å£
/// </summary>
public interface IDataAcquisitionStrategy
{
    /// <summary>
    /// é‡‡æ ·ç‡ (Hz)
    /// </summary>
    int SampleRate { get; }

    /// <summary>
    /// åˆ›å»ºé‡‡é›†çš„ Observable æµ
    /// </summary>
    IObservable<RawHardwareData> CreateAcquisitionStream(
        IHardwareAdapter adapter,
        IScheduler scheduler,
        CancellationToken cancellationToken
    );
}

/// <summary>
/// å›ºå®šé¢‘ç‡é‡‡é›†ç­–ç•¥
/// </summary>
public class FixedRateStrategy : IDataAcquisitionStrategy
{
    public int SampleRate { get; }

    public FixedRateStrategy(int sampleRate)
    {
        SampleRate = sampleRate;
    }

    public IObservable<RawHardwareData> CreateAcquisitionStream(
        IHardwareAdapter adapter,
        IScheduler scheduler,
        CancellationToken cancellationToken)
    {
        return Observable
            .Generate(
                0L,
                _ => !cancellationToken.IsCancellationRequested,
                tick => tick + 1,
                _ => adapter.ReadData(), // è¯»å–ç¡¬ä»¶æ•°æ®
                _ => CalculateInterval())
            .ObserveOn(scheduler);
    }

    private TimeSpan CalculateInterval()
    {
        return TimeSpan.FromTicks(Stopwatch.Frequency / SampleRate);
    }
}

/// <summary>
/// è§¦å‘å¼é‡‡é›†ç­–ç•¥ (äº‹ä»¶é©±åŠ¨)
/// </summary>
public class TriggerBasedStrategy : IDataAcquisitionStrategy
{
    private readonly IObservable<TriggerEvent> _triggerSource;

    public int SampleRate => 0; // éå‘¨æœŸæ€§

    public TriggerBasedStrategy(IObservable<TriggerEvent> triggerSource)
    {
        _triggerSource = triggerSource;
    }

    public IObservable<RawHardwareData> CreateAcquisitionStream(
        IHardwareAdapter adapter,
        IScheduler scheduler,
        CancellationToken cancellationToken)
    {
        return _triggerSource
            .TakeWhile(_ => !cancellationToken.IsCancellationRequested)
            .Select(_ => adapter.ReadData())
            .ObserveOn(scheduler);
    }
}

/// <summary>
/// è‡ªé€‚åº”é‡‡é›†ç­–ç•¥ (åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡)
/// </summary>
public class AdaptiveRateStrategy : IDataAcquisitionStrategy
{
    private int _currentSampleRate;
    private readonly int _minSampleRate;
    private readonly int _maxSampleRate;
    private readonly Func<RawHardwareData, bool> _needHighSpeedCondition;

    public int SampleRate => _currentSampleRate;

    public AdaptiveRateStrategy(
        int minSampleRate,
        int maxSampleRate,
        Func<RawHardwareData, bool> needHighSpeedCondition)
    {
        _minSampleRate = minSampleRate;
        _maxSampleRate = maxSampleRate;
        _currentSampleRate = minSampleRate;
        _needHighSpeedCondition = needHighSpeedCondition;
    }

    public IObservable<RawHardwareData> CreateAcquisitionStream(
        IHardwareAdapter adapter,
        IScheduler scheduler,
        CancellationToken cancellationToken)
    {
        return Observable.Create<RawHardwareData>(observer =>
        {
            var disposable = new CompositeDisposable();

            // åŠ¨æ€è°ƒæ•´é‡‡æ ·ç‡çš„é€»è¾‘
            var adjustmentStream = Observable
                .Interval(TimeSpan.FromSeconds(1))
                .Subscribe(_ =>
                {
                    var data = adapter.ReadData();

                    // æ ¹æ®æ¡ä»¶è°ƒæ•´é‡‡æ ·ç‡
                    if (_needHighSpeedCondition(data))
                    {
                        _currentSampleRate = Math.Min(_currentSampleRate * 2, _maxSampleRate);
                    }
                    else
                    {
                        _currentSampleRate = Math.Max(_currentSampleRate / 2, _minSampleRate);
                    }

                    observer.OnNext(data);
                });

            disposable.Add(adjustmentStream);
            return disposable;
        });
    }
}
```

#### 1.2 æ•°æ®å¤„ç†ç®¡é“

```csharp
/// <summary>
/// æ•°æ®å¤„ç†ç®¡é“èŠ‚ç‚¹æ¥å£
/// </summary>
public interface IDataProcessor
{
    IObservable<ProcessedData> Process(IObservable<RawHardwareData> source);
}

/// <summary>
/// æ•°æ®éªŒè¯å¤„ç†å™¨
/// </summary>
public class DataValidationProcessor : IDataProcessor
{
    private readonly IDataValidator _validator;

    public DataValidationProcessor(IDataValidator validator)
    {
        _validator = validator;
    }

    public IObservable<ProcessedData> Process(IObservable<RawHardwareData> source)
    {
        return source
            .Select(raw => new ProcessedData
            {
                Raw = raw,
                Quality = _validator.Validate(raw),
                Timestamp = Stopwatch.GetTimestamp()
            })
            .Where(data => data.Quality != DataQuality.Bad); // è¿‡æ»¤åæ•°æ®
    }
}

/// <summary>
/// æ•°æ®è½¬æ¢å¤„ç†å™¨
/// </summary>
public class DataTransformProcessor : IDataProcessor
{
    private readonly ConcurrentDictionary<long, HardwareSignalChannel> _signalChannels;

    public DataTransformProcessor(ConcurrentDictionary<long, HardwareSignalChannel> signalChannels)
    {
        _signalChannels = signalChannels;
    }

    public IObservable<ProcessedData> Process(IObservable<RawHardwareData> source)
    {
        return source.Select(raw =>
        {
            var batchModel = ConvertToCollectModel(raw);

            return new ProcessedData
            {
                Raw = raw,
                CollectModel = batchModel,
                Timestamp = raw.Timestamp,
                Quality = DataQuality.Good
            };
        });
    }

    private BatchCollectItemModel ConvertToCollectModel(RawHardwareData raw)
    {
        // è½¬æ¢é€»è¾‘ (ä»åŸæœ‰çš„ StructDataToCollectModel è¿ç§»)
        var result = new BatchCollectItemModel();

        foreach (var signal in _signalChannels.Values)
        {
            var index = signal.SignalAddressIndex;
            if (index < 10 && index < raw.Net_AD_N.Length)
            {
                result.Net_AD_N.Add(signal.SignalId, raw.Net_AD_N[index]);
            }
            else
            {
                var sIndex = index % 10;
                if (sIndex < raw.Net_AD_S.Length)
                {
                    result.Net_AD_S.Add(signal.SignalId, raw.Net_AD_S[sIndex]);
                }
            }
        }

        return result;
    }
}

/// <summary>
/// æ•°æ®èšåˆå¤„ç†å™¨ (æ”¯æŒæ»‘åŠ¨çª—å£ç»Ÿè®¡)
/// </summary>
public class DataAggregationProcessor : IDataProcessor
{
    private readonly TimeSpan _windowSize;

    public DataAggregationProcessor(TimeSpan windowSize)
    {
        _windowSize = windowSize;
    }

    public IObservable<ProcessedData> Process(IObservable<RawHardwareData> source)
    {
        return source
            .Buffer(_windowSize)
            .Select(batch => new ProcessedData
            {
                AggregatedData = new AggregatedMetrics
                {
                    Count = batch.Count,
                    Mean = batch.Average(d => d.Net_FeedLoadN),
                    Max = batch.Max(d => d.Net_FeedLoadN),
                    Min = batch.Min(d => d.Net_FeedLoadN),
                    StdDev = CalculateStdDev(batch.Select(d => d.Net_FeedLoadN))
                },
                Quality = DataQuality.Good
            });
    }

    private double CalculateStdDev(IEnumerable<float> values)
    {
        var mean = values.Average();
        var variance = values.Average(v => Math.Pow(v - mean, 2));
        return Math.Sqrt(variance);
    }
}
```

#### 1.3 èƒŒå‹ç­–ç•¥

```csharp
/// <summary>
/// èƒŒå‹ç­–ç•¥æ¥å£
/// </summary>
public interface IBackpressureStrategy
{
    IObservable<T> Apply<T>(IObservable<T> source);
}

/// <summary>
/// ä¸¢å¼ƒç­–ç•¥ (ä¿ç•™æœ€æ–°)
/// </summary>
public class DropOldestStrategy : IBackpressureStrategy
{
    private readonly int _bufferSize;

    public DropOldestStrategy(int bufferSize)
    {
        _bufferSize = bufferSize;
    }

    public IObservable<T> Apply<T>(IObservable<T> source)
    {
        return Observable.Create<T>(observer =>
        {
            var buffer = new CircularBuffer<T>(_bufferSize);

            return source.Subscribe(
                item =>
                {
                    if (buffer.IsFull)
                    {
                        buffer.RemoveOldest(); // ç§»é™¤æœ€æ—§çš„æ•°æ®
                    }
                    buffer.Add(item);
                    observer.OnNext(item);
                },
                observer.OnError,
                observer.OnCompleted
            );
        });
    }
}

/// <summary>
/// é‡‡æ ·ç­–ç•¥ (é™ä½æ•°æ®ç‡)
/// </summary>
public class SamplingStrategy : IBackpressureStrategy
{
    private readonly TimeSpan _sampleInterval;

    public SamplingStrategy(TimeSpan sampleInterval)
    {
        _sampleInterval = sampleInterval;
    }

    public IObservable<T> Apply<T>(IObservable<T> source)
    {
        return source.Sample(_sampleInterval); // Rx.NET çš„ Sample æ“ä½œç¬¦
    }
}

/// <summary>
/// æ‰¹å¤„ç†ç­–ç•¥ (å‡å°‘äº‹ä»¶é¢‘ç‡)
/// </summary>
public class BatchingStrategy : IBackpressureStrategy
{
    private readonly int _batchSize;

    public BatchingStrategy(int batchSize)
    {
        _batchSize = batchSize;
    }

    public IObservable<T> Apply<T>(IObservable<T> source)
    {
        return source
            .Buffer(_batchSize)
            .SelectMany(batch => batch); // å±•å¹³æ‰¹æ¬¡
    }
}

/// <summary>
/// èŠ‚æµç­–ç•¥ (é™åˆ¶æ•°æ®ç‡)
/// </summary>
public class ThrottleStrategy : IBackpressureStrategy
{
    private readonly TimeSpan _throttleDuration;

    public ThrottleStrategy(TimeSpan throttleDuration)
    {
        _throttleDuration = throttleDuration;
    }

    public IObservable<T> Apply<T>(IObservable<T> source)
    {
        return source.Throttle(_throttleDuration); // ä»…å‘å‡ºæœ€åä¸€ä¸ªå€¼
    }
}
```

#### 1.4 å®Œæ•´çš„é‡‡é›†ç®¡é“

```csharp
/// <summary>
/// æ•°æ®é‡‡é›†ç®¡é“æ„å»ºå™¨
/// </summary>
public class DataAcquisitionPipelineBuilder
{
    private IDataAcquisitionStrategy? _strategy;
    private readonly List<IDataProcessor> _processors = new();
    private IBackpressureStrategy? _backpressureStrategy;
    private IScheduler? _scheduler;

    public DataAcquisitionPipelineBuilder WithStrategy(IDataAcquisitionStrategy strategy)
    {
        _strategy = strategy;
        return this;
    }

    public DataAcquisitionPipelineBuilder AddProcessor(IDataProcessor processor)
    {
        _processors.Add(processor);
        return this;
    }

    public DataAcquisitionPipelineBuilder WithBackpressure(IBackpressureStrategy strategy)
    {
        _backpressureStrategy = strategy;
        return this;
    }

    public DataAcquisitionPipelineBuilder OnScheduler(IScheduler scheduler)
    {
        _scheduler = scheduler;
        return this;
    }

    public DataAcquisitionPipeline Build(IHardwareAdapter adapter)
    {
        if (_strategy == null) throw new InvalidOperationException("Strategy not set");
        if (_scheduler == null) _scheduler = TaskPoolScheduler.Default;

        return new DataAcquisitionPipeline(
            adapter,
            _strategy,
            _processors,
            _backpressureStrategy,
            _scheduler
        );
    }
}

/// <summary>
/// æ•°æ®é‡‡é›†ç®¡é“
/// </summary>
public class DataAcquisitionPipeline : IDisposable
{
    private readonly IHardwareAdapter _adapter;
    private readonly IDataAcquisitionStrategy _strategy;
    private readonly List<IDataProcessor> _processors;
    private readonly IBackpressureStrategy? _backpressureStrategy;
    private readonly IScheduler _scheduler;
    private readonly CancellationTokenSource _cts = new();
    private IDisposable? _subscription;

    public IObservable<ProcessedData> DataStream { get; }

    public DataAcquisitionPipeline(
        IHardwareAdapter adapter,
        IDataAcquisitionStrategy strategy,
        List<IDataProcessor> processors,
        IBackpressureStrategy? backpressureStrategy,
        IScheduler scheduler)
    {
        _adapter = adapter;
        _strategy = strategy;
        _processors = processors;
        _backpressureStrategy = backpressureStrategy;
        _scheduler = scheduler;

        DataStream = BuildPipeline();
    }

    private IObservable<ProcessedData> BuildPipeline()
    {
        // 1. åˆ›å»ºåŸå§‹æ•°æ®æµ
        var rawStream = _strategy.CreateAcquisitionStream(_adapter, _scheduler, _cts.Token);

        // 2. åº”ç”¨èƒŒå‹ç­–ç•¥
        if (_backpressureStrategy != null)
        {
            rawStream = _backpressureStrategy.Apply(rawStream);
        }

        // 3. åº”ç”¨å¤„ç†å™¨é“¾
        IObservable<ProcessedData> processedStream = Observable.Empty<ProcessedData>();

        foreach (var processor in _processors)
        {
            processedStream = processor.Process(rawStream);
            // ä¸‹ä¸€ä¸ªå¤„ç†å™¨çš„è¾“å…¥æ˜¯ä¸Šä¸€ä¸ªå¤„ç†å™¨çš„è¾“å‡º
            rawStream = processedStream.Select(pd => pd.Raw);
        }

        return processedStream
            .Publish()  // å¤šæ’­ï¼Œé¿å…é‡å¤æ‰§è¡Œ
            .RefCount(); // è‡ªåŠ¨è¿æ¥/æ–­å¼€
    }

    public void Start()
    {
        // ç®¡é“é€šè¿‡è®¢é˜…è‡ªåŠ¨å¯åŠ¨
        _subscription = DataStream.Subscribe(
            data => { /* æ•°æ®å·²å‘å¸ƒåˆ°æµä¸­ */ },
            ex => { /* é”™è¯¯å¤„ç† */ },
            () => { /* å®Œæˆå¤„ç† */ }
        );
    }

    public void Stop()
    {
        _cts.Cancel();
        _subscription?.Dispose();
    }

    public void Dispose()
    {
        Stop();
        _cts?.Dispose();
    }
}
```

#### 1.5 ä½¿ç”¨ç¤ºä¾‹

```csharp
// æ„å»ºé«˜æ€§èƒ½æ•°æ®é‡‡é›†ç®¡é“
var pipeline = new DataAcquisitionPipelineBuilder()
    // 1. è®¾ç½®é‡‡é›†ç­–ç•¥ (10kHz å›ºå®šé‡‡æ ·ç‡)
    .WithStrategy(new FixedRateStrategy(sampleRate: 10000))

    // 2. æ·»åŠ æ•°æ®éªŒè¯
    .AddProcessor(new DataValidationProcessor(new HardwareDataValidator()))

    // 3. æ·»åŠ æ•°æ®è½¬æ¢
    .AddProcessor(new DataTransformProcessor(signalChannels))

    // 4. æ·»åŠ æ•°æ®èšåˆ (æ¯100msè®¡ç®—ç»Ÿè®¡ä¿¡æ¯)
    .AddProcessor(new DataAggregationProcessor(TimeSpan.FromMilliseconds(100)))

    // 5. åº”ç”¨èƒŒå‹ç­–ç•¥ (ç¼“å†²åŒºæ»¡æ—¶ä¸¢å¼ƒæœ€æ—§æ•°æ®)
    .WithBackpressure(new DropOldestStrategy(bufferSize: 5000))

    // 6. åœ¨é«˜ä¼˜å…ˆçº§çº¿ç¨‹ä¸Šæ‰§è¡Œ
    .OnScheduler(new EventLoopScheduler(ts => new Thread(ts)
    {
        Name = "DataAcquisition",
        IsBackground = true,
        Priority = ThreadPriority.Highest
    }))

    // 7. æ„å»ºç®¡é“
    .Build(hardwareAdapter);

// å¯åŠ¨é‡‡é›†
pipeline.Start();

// è®¢é˜…æ•°æ®æµ
pipeline.DataStream.Subscribe(data =>
{
    // å¤„ç†é‡‡é›†åˆ°çš„æ•°æ®
    Console.WriteLine($"æ”¶åˆ°æ•°æ®: {data.CollectModel.Net_FeedLoadN} kN");
});

// åœæ­¢é‡‡é›†
pipeline.Stop();
```

---

### 2. å‘½ä»¤æ‰§è¡Œç®¡é“ (Command Execution Pipeline)

#### 2.1 å‘½ä»¤æ¨¡å¼è®¾è®¡

```csharp
/// <summary>
/// å‘½ä»¤æ¥å£
/// </summary>
public interface ICommand
{
    /// <summary>
    /// å‘½ä»¤å”¯ä¸€ ID
    /// </summary>
    string CommandId { get; }

    /// <summary>
    /// ç›®æ ‡è®¾å¤‡ ID
    /// </summary>
    long DeviceId { get; }

    /// <summary>
    /// å‘½ä»¤ç±»å‹
    /// </summary>
    CommandTypeEnum Type { get; }

    /// <summary>
    /// å‘½ä»¤ä¼˜å…ˆçº§
    /// </summary>
    CommandPriority Priority { get; }

    /// <summary>
    /// æ‰§è¡Œå‘½ä»¤ (å¼‚æ­¥)
    /// </summary>
    Task<CommandResult> ExecuteAsync(IHardwareAdapter adapter, CancellationToken cancellationToken);

    /// <summary>
    /// éªŒè¯å‘½ä»¤å‚æ•°
    /// </summary>
    bool Validate(out string errorMessage);
}

/// <summary>
/// å‘½ä»¤ä¼˜å…ˆçº§
/// </summary>
public enum CommandPriority
{
    Low = 0,
    Normal = 1,
    High = 2,
    Critical = 3  // å¦‚ç´§æ€¥åœæ­¢
}

/// <summary>
/// å‘½ä»¤æ‰§è¡Œç»“æœ
/// </summary>
public record CommandResult
{
    public bool IsSuccess { get; init; }
    public string Message { get; init; } = string.Empty;
    public Exception? Exception { get; init; }
    public Dictionary<string, object>? Data { get; init; }
}

/// <summary>
/// æŠ½è±¡å‘½ä»¤åŸºç±»
/// </summary>
public abstract class CommandBase : ICommand
{
    public string CommandId { get; } = Guid.NewGuid().ToString();
    public long DeviceId { get; protected init; }
    public abstract CommandTypeEnum Type { get; }
    public virtual CommandPriority Priority => CommandPriority.Normal;

    public abstract Task<CommandResult> ExecuteAsync(
        IHardwareAdapter adapter,
        CancellationToken cancellationToken);

    public virtual bool Validate(out string errorMessage)
    {
        errorMessage = string.Empty;
        return true;
    }
}
```

#### 2.2 å…·ä½“å‘½ä»¤å®ç°

```csharp
/// <summary>
/// é™æ€æ§åˆ¶å‘½ä»¤
/// </summary>
public class StaticControlCommand : CommandBase
{
    public StaticControlParams Parameters { get; }

    public override CommandTypeEnum Type => CommandTypeEnum.StaticControl;

    public StaticControlCommand(StaticControlParams parameters)
    {
        Parameters = parameters;
        DeviceId = parameters.DeviceId;
    }

    public override bool Validate(out string errorMessage)
    {
        if (Parameters.Speed <= 0)
        {
            errorMessage = "é€Ÿåº¦å¿…é¡»å¤§äº0";
            return false;
        }

        if (Parameters.TargetValue < 0)
        {
            errorMessage = "ç›®æ ‡å€¼ä¸èƒ½ä¸ºè´Ÿæ•°";
            return false;
        }

        errorMessage = string.Empty;
        return true;
    }

    public override async Task<CommandResult> ExecuteAsync(
        IHardwareAdapter adapter,
        CancellationToken cancellationToken)
    {
        try
        {
            // 1. è®¾ç½®æ§åˆ¶æ¨¡å¼ä¸ºé™æ€
            await adapter.SetControlModeAsync(SystemControlState.Static, cancellationToken);

            // 2. å‘é€é™æ€æ§åˆ¶å‚æ•°
            var success = await adapter.SetStaticControlAsync(Parameters, cancellationToken);

            if (!success)
            {
                return new CommandResult
                {
                    IsSuccess = false,
                    Message = "é™æ€æ§åˆ¶å‘½ä»¤æ‰§è¡Œå¤±è´¥"
                };
            }

            return new CommandResult
            {
                IsSuccess = true,
                Message = "é™æ€æ§åˆ¶å‘½ä»¤æ‰§è¡ŒæˆåŠŸ"
            };
        }
        catch (Exception ex)
        {
            return new CommandResult
            {
                IsSuccess = false,
                Message = ex.Message,
                Exception = ex
            };
        }
    }
}

/// <summary>
/// åŠ¨æ€æ§åˆ¶å‘½ä»¤
/// </summary>
public class DynamicControlCommand : CommandBase
{
    public DynamicControlParams Parameters { get; }

    public override CommandTypeEnum Type => CommandTypeEnum.DynamicControl;

    public DynamicControlCommand(DynamicControlParams parameters)
    {
        Parameters = parameters;
        DeviceId = parameters.DeviceId;
    }

    public override bool Validate(out string errorMessage)
    {
        if (Parameters.Frequency <= 0)
        {
            errorMessage = "é¢‘ç‡å¿…é¡»å¤§äº0";
            return false;
        }

        if (Parameters.Amplitude < 0)
        {
            errorMessage = "å¹…å€¼ä¸èƒ½ä¸ºè´Ÿæ•°";
            return false;
        }

        errorMessage = string.Empty;
        return true;
    }

    public override async Task<CommandResult> ExecuteAsync(
        IHardwareAdapter adapter,
        CancellationToken cancellationToken)
    {
        try
        {
            // è®¾ç½®æ§åˆ¶æ¨¡å¼ä¸ºåŠ¨æ€
            await adapter.SetControlModeAsync(SystemControlState.Dynamic, cancellationToken);

            // å‘é€åŠ¨æ€æ§åˆ¶å‚æ•°
            var success = await adapter.SetDynamicControlAsync(Parameters, cancellationToken);

            return new CommandResult
            {
                IsSuccess = success,
                Message = success ? "åŠ¨æ€æ§åˆ¶å‘½ä»¤æ‰§è¡ŒæˆåŠŸ" : "åŠ¨æ€æ§åˆ¶å‘½ä»¤æ‰§è¡Œå¤±è´¥"
            };
        }
        catch (Exception ex)
        {
            return new CommandResult
            {
                IsSuccess = false,
                Message = ex.Message,
                Exception = ex
            };
        }
    }
}

/// <summary>
/// ç´§æ€¥åœæ­¢å‘½ä»¤ (æœ€é«˜ä¼˜å…ˆçº§)
/// </summary>
public class EmergencyStopCommand : CommandBase
{
    public override CommandTypeEnum Type => CommandTypeEnum.EmergencyStop;

    public override CommandPriority Priority => CommandPriority.Critical;

    public EmergencyStopCommand(long deviceId)
    {
        DeviceId = deviceId;
    }

    public override async Task<CommandResult> ExecuteAsync(
        IHardwareAdapter adapter,
        CancellationToken cancellationToken)
    {
        try
        {
            // ç«‹å³åœæ­¢æ‰€æœ‰è¿åŠ¨
            await adapter.EmergencyStopAsync(cancellationToken);

            // å…³é—­é˜€é—¨
            await adapter.SetValveStateAsync(false, cancellationToken);

            return new CommandResult
            {
                IsSuccess = true,
                Message = "ç´§æ€¥åœæ­¢å‘½ä»¤æ‰§è¡ŒæˆåŠŸ"
            };
        }
        catch (Exception ex)
        {
            return new CommandResult
            {
                IsSuccess = false,
                Message = ex.Message,
                Exception = ex
            };
        }
    }
}
```

#### 2.3 å‘½ä»¤é˜Ÿåˆ—

```csharp
/// <summary>
/// å‘½ä»¤é˜Ÿåˆ— (æ”¯æŒä¼˜å…ˆçº§)
/// </summary>
public class CommandQueue : IDisposable
{
    private readonly PriorityQueue<ICommand, CommandPriority> _queue = new();
    private readonly SemaphoreSlim _semaphore = new(0);
    private readonly ReaderWriterLockSlim _lock = new();
    private bool _disposed = false;

    /// <summary>
    /// å…¥é˜Ÿå‘½ä»¤
    /// </summary>
    public void Enqueue(ICommand command)
    {
        _lock.EnterWriteLock();
        try
        {
            _queue.Enqueue(command, command.Priority);
            _semaphore.Release(); // é€šçŸ¥æœ‰æ–°å‘½ä»¤
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    /// <summary>
    /// å‡ºé˜Ÿå‘½ä»¤ (å¼‚æ­¥ç­‰å¾…)
    /// </summary>
    public async Task<ICommand?> DequeueAsync(CancellationToken cancellationToken)
    {
        await _semaphore.WaitAsync(cancellationToken);

        _lock.EnterWriteLock();
        try
        {
            if (_queue.TryDequeue(out var command, out _))
            {
                return command;
            }
            return null;
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    /// <summary>
    /// æ¸…ç©ºé˜Ÿåˆ—
    /// </summary>
    public void Clear()
    {
        _lock.EnterWriteLock();
        try
        {
            _queue.Clear();
        }
        finally
        {
            _lock.ExitWriteLock();
        }
    }

    /// <summary>
    /// è·å–é˜Ÿåˆ—é•¿åº¦
    /// </summary>
    public int Count
    {
        get
        {
            _lock.EnterReadLock();
            try
            {
                return _queue.Count;
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _lock?.Dispose();
            _semaphore?.Dispose();
            _disposed = true;
        }
    }
}
```

#### 2.4 å‘½ä»¤æ‰§è¡Œå™¨

```csharp
/// <summary>
/// å‘½ä»¤æ‰§è¡Œå™¨é…ç½®
/// </summary>
public record CommandExecutorOptions
{
    /// <summary>
    /// æœ€å¤§é‡è¯•æ¬¡æ•°
    /// </summary>
    public int MaxRetryCount { get; init; } = 3;

    /// <summary>
    /// åˆå§‹é‡è¯•å»¶è¿Ÿ (æŒ‡æ•°é€€é¿)
    /// </summary>
    public TimeSpan InitialRetryDelay { get; init; } = TimeSpan.FromMilliseconds(100);

    /// <summary>
    /// å‘½ä»¤è¶…æ—¶æ—¶é—´
    /// </summary>
    public TimeSpan CommandTimeout { get; init; } = TimeSpan.FromSeconds(5);

    /// <summary>
    /// æ˜¯å¦å¯ç”¨ç†”æ–­å™¨
    /// </summary>
    public bool EnableCircuitBreaker { get; init; } = true;

    /// <summary>
    /// ç†”æ–­é˜ˆå€¼ (è¿ç»­å¤±è´¥æ¬¡æ•°)
    /// </summary>
    public int CircuitBreakerThreshold { get; init; } = 5;
}

/// <summary>
/// å‘½ä»¤æ‰§è¡Œå™¨
/// </summary>
public class CommandExecutor : IDisposable
{
    private readonly IHardwareAdapter _adapter;
    private readonly CommandQueue _queue;
    private readonly CommandExecutorOptions _options;
    private readonly Subject<CommandStatusChangeEvent> _statusStream = new();
    private readonly CancellationTokenSource _cts = new();
    private readonly SemaphoreSlim _executionLock = new(1, 1); // äº’æ–¥é”
    private Task? _executionTask;
    private int _consecutiveFailures = 0;
    private bool _circuitOpen = false;

    public IObservable<CommandStatusChangeEvent> StatusStream => _statusStream.AsObservable();

    public CommandExecutor(
        IHardwareAdapter adapter,
        CommandQueue queue,
        CommandExecutorOptions options)
    {
        _adapter = adapter;
        _queue = queue;
        _options = options;
    }

    /// <summary>
    /// å¯åŠ¨å‘½ä»¤æ‰§è¡Œå¾ªç¯
    /// </summary>
    public void Start()
    {
        _executionTask = Task.Run(async () => await ExecutionLoopAsync(_cts.Token));
    }

    /// <summary>
    /// åœæ­¢å‘½ä»¤æ‰§è¡Œ
    /// </summary>
    public async Task StopAsync()
    {
        _cts.Cancel();
        if (_executionTask != null)
        {
            await _executionTask;
        }
    }

    /// <summary>
    /// å‘½ä»¤æ‰§è¡Œå¾ªç¯
    /// </summary>
    private async Task ExecutionLoopAsync(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                // ä»é˜Ÿåˆ—ä¸­å–å‡ºå‘½ä»¤
                var command = await _queue.DequeueAsync(cancellationToken);
                if (command == null) continue;

                // æ£€æŸ¥ç†”æ–­å™¨
                if (_circuitOpen && _options.EnableCircuitBreaker)
                {
                    PublishStatus(command, CommandExecuteStatusEnum.Failed, "ç†”æ–­å™¨å·²æ‰“å¼€");
                    continue;
                }

                // æ‰§è¡Œå‘½ä»¤
                await ExecuteCommandAsync(command, cancellationToken);
            }
            catch (OperationCanceledException)
            {
                break;
            }
            catch (Exception ex)
            {
                // è®°å½•é”™è¯¯ä½†ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªå‘½ä»¤
                Console.WriteLine($"å‘½ä»¤æ‰§è¡Œå¾ªç¯é”™è¯¯: {ex.Message}");
            }
        }
    }

    /// <summary>
    /// æ‰§è¡Œå•ä¸ªå‘½ä»¤ (å¸¦é‡è¯•å’Œè¶…æ—¶)
    /// </summary>
    private async Task ExecuteCommandAsync(ICommand command, CancellationToken cancellationToken)
    {
        // äº’æ–¥é”: åŒä¸€æ—¶é—´åªèƒ½æ‰§è¡Œä¸€ä¸ªå‘½ä»¤
        await _executionLock.WaitAsync(cancellationToken);
        try
        {
            // éªŒè¯å‘½ä»¤
            if (!command.Validate(out var validationError))
            {
                PublishStatus(command, CommandExecuteStatusEnum.Failed, validationError);
                return;
            }

            // å‘å¸ƒ "æ‰§è¡Œä¸­" çŠ¶æ€
            PublishStatus(command, CommandExecuteStatusEnum.Executing);

            // å¸¦é‡è¯•çš„æ‰§è¡Œ
            CommandResult? result = null;
            for (int attempt = 0; attempt <= _options.MaxRetryCount; attempt++)
            {
                try
                {
                    // è®¾ç½®è¶…æ—¶
                    using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                    timeoutCts.CancelAfter(_options.CommandTimeout);

                    // æ‰§è¡Œå‘½ä»¤
                    result = await command.ExecuteAsync(_adapter, timeoutCts.Token);

                    if (result.IsSuccess)
                    {
                        // æˆåŠŸ: é‡ç½®å¤±è´¥è®¡æ•°
                        _consecutiveFailures = 0;
                        _circuitOpen = false;
                        PublishStatus(command, CommandExecuteStatusEnum.Completed, result.Message);
                        return;
                    }
                    else
                    {
                        // å¤±è´¥ä½†å¯ä»¥é‡è¯•
                        if (attempt < _options.MaxRetryCount)
                        {
                            var delay = CalculateRetryDelay(attempt);
                            await Task.Delay(delay, cancellationToken);
                        }
                    }
                }
                catch (OperationCanceledException) when (!cancellationToken.IsCancellationRequested)
                {
                    // è¶…æ—¶
                    PublishStatus(command, CommandExecuteStatusEnum.Timeout, "å‘½ä»¤æ‰§è¡Œè¶…æ—¶");
                    break;
                }
                catch (Exception ex)
                {
                    result = new CommandResult
                    {
                        IsSuccess = false,
                        Message = ex.Message,
                        Exception = ex
                    };

                    if (attempt < _options.MaxRetryCount)
                    {
                        var delay = CalculateRetryDelay(attempt);
                        await Task.Delay(delay, cancellationToken);
                    }
                }
            }

            // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
            _consecutiveFailures++;
            if (_consecutiveFailures >= _options.CircuitBreakerThreshold)
            {
                _circuitOpen = true; // æ‰“å¼€ç†”æ–­å™¨
            }

            PublishStatus(command, CommandExecuteStatusEnum.Failed,
                result?.Message ?? "å‘½ä»¤æ‰§è¡Œå¤±è´¥");
        }
        finally
        {
            _executionLock.Release();
        }
    }

    /// <summary>
    /// è®¡ç®—é‡è¯•å»¶è¿Ÿ (æŒ‡æ•°é€€é¿)
    /// </summary>
    private TimeSpan CalculateRetryDelay(int attempt)
    {
        var multiplier = Math.Pow(2, attempt);
        var delay = TimeSpan.FromMilliseconds(_options.InitialRetryDelay.TotalMilliseconds * multiplier);

        // æ·»åŠ éšæœºæŠ–åŠ¨ (é¿å…æƒŠç¾¤æ•ˆåº”)
        var jitter = Random.Shared.Next(0, 100);
        return delay + TimeSpan.FromMilliseconds(jitter);
    }

    /// <summary>
    /// å‘å¸ƒå‘½ä»¤çŠ¶æ€äº‹ä»¶
    /// </summary>
    private void PublishStatus(ICommand command, CommandExecuteStatusEnum status, string? message = null)
    {
        _statusStream.OnNext(new CommandStatusChangeEvent
        {
            CommandId = command.CommandId,
            DeviceId = command.DeviceId,
            Status = status,
            Type = command.Type,
            Timestamp = Stopwatch.GetTimestamp(),
            Message = message
        });
    }

    public void Dispose()
    {
        _cts?.Cancel();
        _cts?.Dispose();
        _executionLock?.Dispose();
        _statusStream?.OnCompleted();
        _statusStream?.Dispose();
    }
}

/// <summary>
/// æ‰©å±•çš„å‘½ä»¤çŠ¶æ€æšä¸¾
/// </summary>
public enum CommandExecuteStatusEnum
{
    NoExecute,    // æœªæ‰§è¡Œ
    Queued,       // å·²å…¥é˜Ÿ
    Executing,    // æ‰§è¡Œä¸­
    Completed,    // å·²å®Œæˆ
    Failed,       // å¤±è´¥
    Timeout,      // è¶…æ—¶
    Cancelled     // å·²å–æ¶ˆ
}
```

#### 2.5 å‘½ä»¤çŠ¶æ€ç®¡ç†å™¨

```csharp
/// <summary>
/// å‘½ä»¤çŠ¶æ€ç®¡ç†å™¨
/// </summary>
public class CommandStateManager
{
    private readonly ConcurrentDictionary<string, CommandStatusChangeEvent> _commandStates = new();
    private readonly Subject<CommandStatusChangeEvent> _stateChangeStream = new();

    public IObservable<CommandStatusChangeEvent> StateChangeStream => _stateChangeStream.AsObservable();

    /// <summary>
    /// æ›´æ–°å‘½ä»¤çŠ¶æ€
    /// </summary>
    public void UpdateCommandState(CommandStatusChangeEvent statusEvent)
    {
        _commandStates.AddOrUpdate(
            statusEvent.CommandId,
            statusEvent,
            (_, _) => statusEvent
        );

        _stateChangeStream.OnNext(statusEvent);
    }

    /// <summary>
    /// è·å–å‘½ä»¤çŠ¶æ€
    /// </summary>
    public CommandStatusChangeEvent? GetCommandState(string commandId)
    {
        _commandStates.TryGetValue(commandId, out var state);
        return state;
    }

    /// <summary>
    /// è·å–è®¾å¤‡çš„æ‰€æœ‰å‘½ä»¤
    /// </summary>
    public IEnumerable<CommandStatusChangeEvent> GetDeviceCommands(long deviceId)
    {
        return _commandStates.Values.Where(cmd => cmd.DeviceId == deviceId);
    }

    /// <summary>
    /// è·å–æ­£åœ¨æ‰§è¡Œçš„å‘½ä»¤
    /// </summary>
    public IEnumerable<CommandStatusChangeEvent> GetExecutingCommands()
    {
        return _commandStates.Values.Where(cmd => cmd.Status == CommandExecuteStatusEnum.Executing);
    }

    /// <summary>
    /// æ¸…ç†æ—§å‘½ä»¤ (ä¿ç•™æœ€è¿‘Nä¸ª)
    /// </summary>
    public void CleanupOldCommands(int keepCount = 1000)
    {
        var commandsToKeep = _commandStates.Values
            .OrderByDescending(cmd => cmd.Timestamp)
            .Take(keepCount)
            .Select(cmd => cmd.CommandId)
            .ToHashSet();

        var keysToRemove = _commandStates.Keys
            .Where(key => !commandsToKeep.Contains(key))
            .ToList();

        foreach (var key in keysToRemove)
        {
            _commandStates.TryRemove(key, out _);
        }
    }
}
```

#### 2.6 ä½¿ç”¨ç¤ºä¾‹

```csharp
// åˆ›å»ºå‘½ä»¤æ‰§è¡ŒåŸºç¡€è®¾æ–½
var queue = new CommandQueue();
var options = new CommandExecutorOptions
{
    MaxRetryCount = 3,
    InitialRetryDelay = TimeSpan.FromMilliseconds(100),
    CommandTimeout = TimeSpan.FromSeconds(5),
    EnableCircuitBreaker = true,
    CircuitBreakerThreshold = 5
};

var executor = new CommandExecutor(hardwareAdapter, queue, options);
var stateManager = new CommandStateManager();

// è®¢é˜…å‘½ä»¤çŠ¶æ€å˜åŒ–
executor.StatusStream.Subscribe(statusEvent =>
{
    stateManager.UpdateCommandState(statusEvent);
    Console.WriteLine($"å‘½ä»¤ {statusEvent.CommandId} çŠ¶æ€å˜æ›´: {statusEvent.Status}");
});

// å¯åŠ¨æ‰§è¡Œå™¨
executor.Start();

// å‘é€é™æ€æ§åˆ¶å‘½ä»¤
var staticCommand = new StaticControlCommand(new StaticControlParams
{
    DeviceId = 1,
    StaticLoadControl = StaticLoadControlEnum.CTRLMODE_LoadN,
    Speed = 10.0f,
    TargetValue = 100.0f
});

queue.Enqueue(staticCommand);

// å‘é€ç´§æ€¥åœæ­¢å‘½ä»¤ (é«˜ä¼˜å…ˆçº§,ä¼šæ’é˜Ÿæ‰§è¡Œ)
var emergencyStop = new EmergencyStopCommand(deviceId: 1);
queue.Enqueue(emergencyStop);

// æŸ¥è¯¢å‘½ä»¤çŠ¶æ€
var state = stateManager.GetCommandState(staticCommand.CommandId);
Console.WriteLine($"å‘½ä»¤çŠ¶æ€: {state?.Status}");

// åœæ­¢æ‰§è¡Œå™¨
await executor.StopAsync();
```

---

### 3. ç¡¬ä»¶æŠ½è±¡å±‚ (Hardware Abstraction Layer)

#### 3.1 ç¡¬ä»¶é€‚é…å™¨æ¥å£

```csharp
/// <summary>
/// ç¡¬ä»¶é€‚é…å™¨æ¥å£ (æŠ½è±¡ç¡¬ä»¶æ“ä½œ)
/// </summary>
public interface IHardwareAdapter : IDisposable
{
    /// <summary>
    /// è®¾å¤‡ ID
    /// </summary>
    long DeviceId { get; }

    /// <summary>
    /// è¿æ¥çŠ¶æ€
    /// </summary>
    HardwareConnectionStatus Status { get; }

    /// <summary>
    /// è¿æ¥çŠ¶æ€æµ
    /// </summary>
    IObservable<HardwareConnectionStatus> StatusStream { get; }

    // ========== è¿æ¥ç®¡ç† ==========

    /// <summary>
    /// è¿æ¥åˆ°ç¡¬ä»¶
    /// </summary>
    Task<bool> ConnectAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// æ–­å¼€ç¡¬ä»¶è¿æ¥
    /// </summary>
    Task<bool> DisconnectAsync(CancellationToken cancellationToken = default);

    // ========== æ•°æ®è¯»å– ==========

    /// <summary>
    /// è¯»å–åŸå§‹ç¡¬ä»¶æ•°æ® (åŒæ­¥,ç”¨äºé«˜é€Ÿé‡‡é›†)
    /// </summary>
    RawHardwareData ReadData();

    /// <summary>
    /// è¯»å–åŸå§‹ç¡¬ä»¶æ•°æ® (å¼‚æ­¥)
    /// </summary>
    Task<RawHardwareData> ReadDataAsync(CancellationToken cancellationToken = default);

    // ========== æ§åˆ¶æ“ä½œ ==========

    /// <summary>
    /// è®¾ç½®æ§åˆ¶æ¨¡å¼
    /// </summary>
    Task<bool> SetControlModeAsync(SystemControlState controlMode, CancellationToken cancellationToken = default);

    /// <summary>
    /// è®¾ç½®é™æ€æ§åˆ¶å‚æ•°
    /// </summary>
    Task<bool> SetStaticControlAsync(StaticControlParams parameters, CancellationToken cancellationToken = default);

    /// <summary>
    /// è®¾ç½®åŠ¨æ€æ§åˆ¶å‚æ•°
    /// </summary>
    Task<bool> SetDynamicControlAsync(DynamicControlParams parameters, CancellationToken cancellationToken = default);

    /// <summary>
    /// è®¾ç½®é˜€é—¨çŠ¶æ€
    /// </summary>
    Task<bool> SetValveStateAsync(bool isOpen, CancellationToken cancellationToken = default);

    /// <summary>
    /// ç´§æ€¥åœæ­¢
    /// </summary>
    Task<bool> EmergencyStopAsync(CancellationToken cancellationToken = default);
}

/// <summary>
/// åŸå§‹ç¡¬ä»¶æ•°æ®ç»“æ„
/// </summary>
public record RawHardwareData
{
    public long Timestamp { get; init; }
    public float[] Net_AD_N { get; init; } = Array.Empty<float>();
    public float[] Net_AD_S { get; init; } = Array.Empty<float>();
    public float Net_PosVref { get; init; }
    public float Net_PosE { get; init; }
    public float Net_CtrlDA { get; init; }
    public int Net_CycleCount { get; init; }
    public int Net_SysState { get; init; }
    public float Net_FeedLoadN { get; init; }
    public int Net_DIVal { get; init; }
    public int Net_DOVal { get; init; }
}
```

#### 3.2 çœŸå®ç¡¬ä»¶é€‚é…å™¨

```csharp
/// <summary>
/// POPNetCtrl ç¡¬ä»¶é€‚é…å™¨ (çœŸå®ç¡¬ä»¶)
/// </summary>
public class POPNetHardwareAdapter : IHardwareAdapter
{
    private readonly int _deviceAddressId;
    private readonly BehaviorSubject<HardwareConnectionStatus> _statusSubject;
    private IntPtr _deviceHandle = IntPtr.Zero;
    private readonly IMemoryPool _memoryPool;

    public long DeviceId { get; }
    public HardwareConnectionStatus Status => _statusSubject.Value;
    public IObservable<HardwareConnectionStatus> StatusStream => _statusSubject.AsObservable();

    public POPNetHardwareAdapter(
        long deviceId,
        int deviceAddressId,
        IMemoryPool memoryPool)
    {
        DeviceId = deviceId;
        _deviceAddressId = deviceAddressId;
        _memoryPool = memoryPool;
        _statusSubject = new BehaviorSubject<HardwareConnectionStatus>(HardwareConnectionStatus.Disconnected);
    }

    public async Task<bool> ConnectAsync(CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var result = POPNetCtrl.NetCtrl01_ConnectToDev(_deviceAddressId, ref _deviceHandle);

            if (result == AddressContanst.OP_SUCCESSFUL)
            {
                _statusSubject.OnNext(HardwareConnectionStatus.Connected);
                return true;
            }

            _statusSubject.OnNext(HardwareConnectionStatus.Error);
            return false;
        }, cancellationToken);
    }

    public async Task<bool> DisconnectAsync(CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            if (_deviceHandle == IntPtr.Zero) return false;

            // è½¯ä»¶é€€å‡º (å…³é—­é˜€å°, DA=0)
            POPNetCtrl.NetCtrl01_Soft_Ext(_deviceHandle);

            var result = POPNetCtrl.NetCtrl01_DisConnectToDev(_deviceHandle);

            if (result == AddressContanst.OP_SUCCESSFUL)
            {
                _deviceHandle = IntPtr.Zero;
                _statusSubject.OnNext(HardwareConnectionStatus.Disconnected);
                return true;
            }

            return false;
        }, cancellationToken);
    }

    public RawHardwareData ReadData()
    {
        uint count = 0;
        if (POPNetCtrl.NetCtrl01_GetAD_HDataCount(_deviceHandle, ref count) != AddressContanst.OP_SUCCESSFUL || count == 0)
        {
            return CreateEmptyData();
        }

        // ä»å†…å­˜æ± ç§Ÿç”¨ç¼“å†²åŒº
        using var buffer = _memoryPool.Rent(Marshal.SizeOf(typeof(TNet_ADHInfo)));

        for (uint i = 0; i < count; i++)
        {
            if (POPNetCtrl.NetCtrl01_GetAD_HInfo(_deviceHandle, buffer.Pointer, (uint)buffer.Size) != AddressContanst.OP_SUCCESSFUL)
            {
                return CreateEmptyData();
            }

            var nativeData = Marshal.PtrToStructure<TNet_ADHInfo>(buffer.Pointer);
            return ConvertToRawData(nativeData);
        }

        return CreateEmptyData();
    }

    public async Task<RawHardwareData> ReadDataAsync(CancellationToken cancellationToken = default)
    {
        return await Task.Run(() => ReadData(), cancellationToken);
    }

    public async Task<bool> SetControlModeAsync(SystemControlState controlMode, CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var result = POPNetCtrl.NetCtrl01_Set_SysCtrlstate(_deviceHandle, (byte)controlMode);
            return result == AddressContanst.OP_SUCCESSFUL;
        }, cancellationToken);
    }

    public async Task<bool> SetStaticControlAsync(StaticControlParams parameters, CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var result = POPNetCtrl.NetCtrl01_S_SetCtrlMod(
                _deviceHandle,
                (uint)parameters.StaticLoadControl,
                parameters.Speed,
                parameters.TargetValue
            );
            return result == AddressContanst.OP_SUCCESSFUL;
        }, cancellationToken);
    }

    public async Task<bool> SetDynamicControlAsync(DynamicControlParams parameters, CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var result = POPNetCtrl.NetCtrl01_Osci_SetWaveInfo(
                (int)DeviceId,
                parameters.MeanValue,
                parameters.Amplitude,
                parameters.Frequency,
                (byte)parameters.WaveType,
                (byte)parameters.ControlMode,
                parameters.CompensateAmplitude,
                parameters.CompensationPhase,
                parameters.CycleCount,
                parameters.IsAdjustedMedian ? 0 : 1
            );
            return result == AddressContanst.OP_SUCCESSFUL;
        }, cancellationToken);
    }

    public async Task<bool> SetValveStateAsync(bool isOpen, CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var v = isOpen ? 1u : 0u;
            var result = POPNetCtrl.NetCtrl01_Set_StationCtrl(_deviceHandle, v, 0);
            return result == AddressContanst.OP_SUCCESSFUL;
        }, cancellationToken);
    }

    public async Task<bool> EmergencyStopAsync(CancellationToken cancellationToken = default)
    {
        return await Task.Run(() =>
        {
            var result = POPNetCtrl.NetCtrl01_Set_TestStartState(_deviceHandle, 0); // åœæ­¢æµ‹è¯•
            return result == AddressContanst.OP_SUCCESSFUL;
        }, cancellationToken);
    }

    private RawHardwareData CreateEmptyData()
    {
        return new RawHardwareData
        {
            Timestamp = Stopwatch.GetTimestamp()
        };
    }

    private RawHardwareData ConvertToRawData(TNet_ADHInfo nativeData)
    {
        return new RawHardwareData
        {
            Timestamp = Stopwatch.GetTimestamp(),
            Net_AD_N = nativeData.Net_AD_N,
            Net_AD_S = nativeData.Net_AD_S,
            Net_PosVref = nativeData.Net_PosVref,
            Net_PosE = nativeData.Net_PosE,
            Net_CtrlDA = nativeData.Net_CtrlDA,
            Net_CycleCount = nativeData.Net_CycleCount,
            Net_SysState = nativeData.Net_SysState,
            Net_FeedLoadN = nativeData.Net_FeedLoadN,
            Net_DIVal = nativeData.Net_DIVal,
            Net_DOVal = nativeData.Net_DOVal
        };
    }

    public void Dispose()
    {
        if (_deviceHandle != IntPtr.Zero)
        {
            DisconnectAsync().Wait();
        }
        _statusSubject?.OnCompleted();
        _statusSubject?.Dispose();
    }
}
```

#### 3.3 æ”¹è¿›çš„å†…å­˜æ± 

```csharp
/// <summary>
/// å†…å­˜æ± æ¥å£
/// </summary>
public interface IMemoryPool
{
    /// <summary>
    /// ç§Ÿç”¨ç¼“å†²åŒº
    /// </summary>
    PooledBuffer Rent(int size);

    /// <summary>
    /// å½’è¿˜ç¼“å†²åŒº
    /// </summary>
    void Return(PooledBuffer buffer);

    /// <summary>
    /// æ¸…ç©ºæ± 
    /// </summary>
    void Clear();
}

/// <summary>
/// æ± åŒ–çš„ç¼“å†²åŒº (RAII æ¨¡å¼)
/// </summary>
public sealed class PooledBuffer : IDisposable
{
    private readonly IMemoryPool _pool;
    private bool _disposed = false;

    public IntPtr Pointer { get; }
    public int Size { get; }

    internal PooledBuffer(IntPtr pointer, int size, IMemoryPool pool)
    {
        Pointer = pointer;
        Size = size;
        _pool = pool;
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _pool.Return(this); // è‡ªåŠ¨å½’è¿˜
            _disposed = true;
        }
    }
}

/// <summary>
/// ä¼˜åŒ–çš„å†…å­˜æ±  (æ”¯æŒä¸åŒå¤§å°çš„ç¼“å†²åŒº)
/// </summary>
public class OptimizedMemoryPool : IMemoryPool
{
    private readonly ConcurrentDictionary<int, ConcurrentBag<IntPtr>> _pools = new();
    private readonly int[] _standardSizes = { 1024, 4096, 16384, 65536, 1048576 }; // æ ‡å‡†å°ºå¯¸

    public PooledBuffer Rent(int size)
    {
        // æ‰¾åˆ°æœ€æ¥è¿‘çš„æ ‡å‡†å°ºå¯¸
        var standardSize = _standardSizes.FirstOrDefault(s => s >= size);
        if (standardSize == 0)
        {
            standardSize = size; // éæ ‡å‡†å°ºå¯¸
        }

        var pool = _pools.GetOrAdd(standardSize, _ => new ConcurrentBag<IntPtr>());

        if (pool.TryTake(out var pointer))
        {
            return new PooledBuffer(pointer, standardSize, this);
        }

        // æ± ä¸­æ²¡æœ‰å¯ç”¨çš„,åˆ†é…æ–°çš„
        var newPointer = Marshal.AllocHGlobal(standardSize);
        return new PooledBuffer(newPointer, standardSize, this);
    }

    public void Return(PooledBuffer buffer)
    {
        if (buffer.Pointer == IntPtr.Zero) return;

        var pool = _pools.GetOrAdd(buffer.Size, _ => new ConcurrentBag<IntPtr>());
        pool.Add(buffer.Pointer);

        // é™åˆ¶æ± å¤§å° (é¿å…å†…å­˜æ³„æ¼)
        if (pool.Count > 100)
        {
            if (pool.TryTake(out var oldPointer))
            {
                Marshal.FreeHGlobal(oldPointer);
            }
        }
    }

    public void Clear()
    {
        foreach (var pool in _pools.Values)
        {
            while (pool.TryTake(out var pointer))
            {
                Marshal.FreeHGlobal(pointer);
            }
        }
        _pools.Clear();
    }
}
```

---

### 4. æ§åˆ¶ç­–ç•¥å±‚ (Control Strategy Layer)

#### 4.1 æ§åˆ¶ç­–ç•¥æ¥å£

```csharp
/// <summary>
/// æ§åˆ¶ç­–ç•¥æ¥å£
/// </summary>
public interface IControlStrategy
{
    /// <summary>
    /// ç­–ç•¥åç§°
    /// </summary>
    string Name { get; }

    /// <summary>
    /// æ”¯æŒçš„æ§åˆ¶æ¨¡å¼
    /// </summary>
    SystemControlState ControlMode { get; }

    /// <summary>
    /// åˆå§‹åŒ–ç­–ç•¥
    /// </summary>
    Task<bool> InitializeAsync(IHardwareAdapter adapter, CancellationToken cancellationToken);

    /// <summary>
    /// æ‰§è¡Œæ§åˆ¶
    /// </summary>
    Task<ControlResult> ExecuteAsync(IHardwareAdapter adapter, CancellationToken cancellationToken);

    /// <summary>
    /// åœæ­¢æ§åˆ¶
    /// </summary>
    Task StopAsync(IHardwareAdapter adapter);
}

/// <summary>
/// æ§åˆ¶ç»“æœ
/// </summary>
public record ControlResult
{
    public bool IsSuccess { get; init; }
    public string Message { get; init; } = string.Empty;
    public Dictionary<string, object>? Data { get; init; }
}
```

#### 4.2 é™æ€æ§åˆ¶ç­–ç•¥

```csharp
/// <summary>
/// é™æ€æ§åˆ¶ç­–ç•¥
/// </summary>
public class StaticControlStrategy : IControlStrategy
{
    private readonly StaticControlParams _parameters;

    public string Name => "StaticControl";
    public SystemControlState ControlMode => SystemControlState.Static;

    public StaticControlStrategy(StaticControlParams parameters)
    {
        _parameters = parameters;
    }

    public async Task<bool> InitializeAsync(IHardwareAdapter adapter, CancellationToken cancellationToken)
    {
        // è®¾ç½®æ§åˆ¶æ¨¡å¼ä¸ºé™æ€
        return await adapter.SetControlModeAsync(SystemControlState.Static, cancellationToken);
    }

    public async Task<ControlResult> ExecuteAsync(IHardwareAdapter adapter, CancellationToken cancellationToken)
    {
        // å‘é€é™æ€æ§åˆ¶å‚æ•°
        var success = await adapter.SetStaticControlAsync(_parameters, cancellationToken);

        return new ControlResult
        {
            IsSuccess = success,
            Message = success ? "é™æ€æ§åˆ¶æ‰§è¡ŒæˆåŠŸ" : "é™æ€æ§åˆ¶æ‰§è¡Œå¤±è´¥"
        };
    }

    public async Task StopAsync(IHardwareAdapter adapter)
    {
        // åœæ­¢æ§åˆ¶ (è®¾ç½®é€Ÿåº¦ä¸º0)
        var stopParams = _parameters with { Speed = 0, TargetValue = 0 };
        await adapter.SetStaticControlAsync(stopParams);
    }
}
```

#### 4.3 PID æ§åˆ¶ç­–ç•¥ (é«˜çº§ç¤ºä¾‹)

```csharp
/// <summary>
/// PID æ§åˆ¶ç­–ç•¥ (é—­ç¯æ§åˆ¶)
/// </summary>
public class PIDControlStrategy : IControlStrategy
{
    private readonly PIDControlParams _parameters;
    private readonly PIDController _pidController;

    public string Name => "PIDControl";
    public SystemControlState ControlMode => SystemControlState.Static;

    public PIDControlStrategy(PIDControlParams parameters)
    {
        _parameters = parameters;
        _pidController = new PIDController(
            parameters.Kp,
            parameters.Ki,
            parameters.Kd,
            parameters.SetPoint
        );
    }

    public async Task<bool> InitializeAsync(IHardwareAdapter adapter, CancellationToken cancellationToken)
    {
        return await adapter.SetControlModeAsync(SystemControlState.Static, cancellationToken);
    }

    public async Task<ControlResult> ExecuteAsync(IHardwareAdapter adapter, CancellationToken cancellationToken)
    {
        // PID æ§åˆ¶å¾ªç¯
        while (!cancellationToken.IsCancellationRequested)
        {
            // è¯»å–å½“å‰å€¼
            var data = await adapter.ReadDataAsync(cancellationToken);
            var currentValue = data.Net_FeedLoadN; // å½“å‰åŠ›å€¼

            // è®¡ç®— PID è¾“å‡º
            var output = _pidController.Compute(currentValue);

            // å‘é€æ§åˆ¶å‘½ä»¤
            var controlParams = new StaticControlParams
            {
                DeviceId = _parameters.DeviceId,
                StaticLoadControl = StaticLoadControlEnum.CTRLMODE_LoadN,
                Speed = Math.Abs(output),
                TargetValue = _parameters.SetPoint + output
            };

            await adapter.SetStaticControlAsync(controlParams, cancellationToken);

            // æ§åˆ¶å‘¨æœŸå»¶è¿Ÿ
            await Task.Delay(_parameters.UpdateInterval, cancellationToken);
        }

        return new ControlResult
        {
            IsSuccess = true,
            Message = "PID æ§åˆ¶æ‰§è¡Œå®Œæˆ"
        };
    }

    public async Task StopAsync(IHardwareAdapter adapter)
    {
        _pidController.Reset();
        var stopParams = new StaticControlParams
        {
            DeviceId = _parameters.DeviceId,
            StaticLoadControl = StaticLoadControlEnum.CTRLMODE_LoadN,
            Speed = 0,
            TargetValue = 0
        };
        await adapter.SetStaticControlAsync(stopParams);
    }
}

/// <summary>
/// PID æ§åˆ¶å‚æ•°
/// </summary>
public record PIDControlParams
{
    public long DeviceId { get; init; }
    public double Kp { get; init; } // æ¯”ä¾‹ç³»æ•°
    public double Ki { get; init; } // ç§¯åˆ†ç³»æ•°
    public double Kd { get; init; } // å¾®åˆ†ç³»æ•°
    public float SetPoint { get; init; } // ç›®æ ‡å€¼
    public TimeSpan UpdateInterval { get; init; } = TimeSpan.FromMilliseconds(100);
}

/// <summary>
/// PID æ§åˆ¶å™¨
/// </summary>
public class PIDController
{
    private readonly double _kp;
    private readonly double _ki;
    private readonly double _kd;
    private readonly float _setPoint;

    private double _integral = 0;
    private double _previousError = 0;

    public PIDController(double kp, double ki, double kd, float setPoint)
    {
        _kp = kp;
        _ki = ki;
        _kd = kd;
        _setPoint = setPoint;
    }

    public float Compute(float currentValue)
    {
        // è®¡ç®—è¯¯å·®
        var error = _setPoint - currentValue;

        // ç§¯åˆ†é¡¹
        _integral += error;

        // å¾®åˆ†é¡¹
        var derivative = error - _previousError;

        // PID è¾“å‡º
        var output = _kp * error + _ki * _integral + _kd * derivative;

        _previousError = error;

        return (float)output;
    }

    public void Reset()
    {
        _integral = 0;
        _previousError = 0;
    }
}
```

---

### 5. æœåŠ¡ç¼–æ’å±‚ (Service Orchestration Layer)

#### 5.1 æ§åˆ¶å™¨ç¼–æ’å™¨

```csharp
/// <summary>
/// æ§åˆ¶å™¨ç¼–æ’å™¨ (ç®¡ç†å¤šä¸ªæ§åˆ¶å™¨)
/// </summary>
public class ControllerOrchestrator : IDisposable
{
    private readonly ConcurrentDictionary<long, ControllerInstance> _controllers = new();
    private readonly IEventBus _eventBus;
    private readonly ILogger _logger;

    public ControllerOrchestrator(IEventBus eventBus, ILogger logger)
    {
        _eventBus = eventBus;
        _logger = logger;
    }

    /// <summary>
    /// åˆ›å»ºæ§åˆ¶å™¨å®ä¾‹
    /// </summary>
    public async Task<bool> CreateControllerAsync(
        long controllerId,
        IHardwareAdapter adapter,
        DataAcquisitionPipeline dataPipeline,
        CommandQueue commandQueue,
        CommandExecutor commandExecutor)
    {
        var instance = new ControllerInstance
        {
            ControllerId = controllerId,
            Adapter = adapter,
            DataPipeline = dataPipeline,
            CommandQueue = commandQueue,
            CommandExecutor = commandExecutor
        };

        if (!_controllers.TryAdd(controllerId, instance))
        {
            _logger.LogWarning($"æ§åˆ¶å™¨ {controllerId} å·²å­˜åœ¨");
            return false;
        }

        // è¿æ¥ç¡¬ä»¶
        var connected = await adapter.ConnectAsync();
        if (!connected)
        {
            _logger.LogError($"æ§åˆ¶å™¨ {controllerId} è¿æ¥å¤±è´¥");
            return false;
        }

        // å¯åŠ¨æ•°æ®é‡‡é›†
        dataPipeline.Start();

        // å¯åŠ¨å‘½ä»¤æ‰§è¡Œå™¨
        commandExecutor.Start();

        _logger.LogInformation($"æ§åˆ¶å™¨ {controllerId} åˆ›å»ºæˆåŠŸ");
        return true;
    }

    /// <summary>
    /// å‘é€å‘½ä»¤åˆ°æŒ‡å®šæ§åˆ¶å™¨
    /// </summary>
    public bool SendCommand(long controllerId, ICommand command)
    {
        if (!_controllers.TryGetValue(controllerId, out var instance))
        {
            _logger.LogWarning($"æ§åˆ¶å™¨ {controllerId} ä¸å­˜åœ¨");
            return false;
        }

        instance.CommandQueue.Enqueue(command);
        _logger.LogInformation($"å‘½ä»¤ {command.CommandId} å·²å‘é€åˆ°æ§åˆ¶å™¨ {controllerId}");
        return true;
    }

    /// <summary>
    /// è®¢é˜…æ§åˆ¶å™¨çš„æ•°æ®æµ
    /// </summary>
    public IObservable<ProcessedData>? GetDataStream(long controllerId)
    {
        if (!_controllers.TryGetValue(controllerId, out var instance))
        {
            return null;
        }

        return instance.DataPipeline.DataStream;
    }

    /// <summary>
    /// è®¢é˜…æ§åˆ¶å™¨çš„å‘½ä»¤çŠ¶æ€æµ
    /// </summary>
    public IObservable<CommandStatusChangeEvent>? GetCommandStatusStream(long controllerId)
    {
        if (!_controllers.TryGetValue(controllerId, out var instance))
        {
            return null;
        }

        return instance.CommandExecutor.StatusStream;
    }

    /// <summary>
    /// åœæ­¢æ‰€æœ‰æ§åˆ¶å™¨
    /// </summary>
    public async Task StopAllAsync()
    {
        var stopTasks = _controllers.Values.Select(async instance =>
        {
            instance.DataPipeline.Stop();
            await instance.CommandExecutor.StopAsync();
            await instance.Adapter.DisconnectAsync();
        });

        await Task.WhenAll(stopTasks);

        _logger.LogInformation("æ‰€æœ‰æ§åˆ¶å™¨å·²åœæ­¢");
    }

    public void Dispose()
    {
        StopAllAsync().Wait();

        foreach (var instance in _controllers.Values)
        {
            instance.DataPipeline?.Dispose();
            instance.CommandExecutor?.Dispose();
            instance.Adapter?.Dispose();
        }

        _controllers.Clear();
    }
}

/// <summary>
/// æ§åˆ¶å™¨å®ä¾‹
/// </summary>
public record ControllerInstance
{
    public long ControllerId { get; init; }
    public IHardwareAdapter Adapter { get; init; } = null!;
    public DataAcquisitionPipeline DataPipeline { get; init; } = null!;
    public CommandQueue CommandQueue { get; init; } = null!;
    public CommandExecutor CommandExecutor { get; init; } = null!;
}
```

---

## ğŸš€ å®ç°è·¯çº¿å›¾

### é˜¶æ®µ 1: åŸºç¡€é‡æ„ (2-3 å‘¨)

**ç›®æ ‡**: ä¿®å¤å…³é”® bug,å»ºç«‹æ–°æ¶æ„åŸºç¡€

#### ä»»åŠ¡:
1. âœ… **ä¿®å¤å†…å­˜ç®¡ç† bug** (BwControllerHardwareDevice.cs:245)
   ```csharp
   // ä¿®æ­£:
   if(_singleBuffer == IntPtr.Zero)  // ä¿®æ”¹ != ä¸º ==
       _singleBuffer = BufferPool.Rent();
   ```

2. âœ… **å®ç°ä¼˜åŒ–çš„å†…å­˜æ± ** (`OptimizedMemoryPool`)
   - æ”¯æŒå¤šç§ç¼“å†²åŒºå¤§å°
   - å®ç° RAII æ¨¡å¼çš„ `PooledBuffer`
   - æ·»åŠ æ± å¤§å°é™åˆ¶

3. âœ… **å®ç°ç¡¬ä»¶é€‚é…å™¨æ¥å£** (`IHardwareAdapter`, `POPNetHardwareAdapter`)
   - æŠ½è±¡ç¡¬ä»¶æ“ä½œ
   - æ‰€æœ‰æ“ä½œå¼‚æ­¥åŒ–
   - ç»Ÿä¸€é”™è¯¯å¤„ç†

4. âœ… **å•å…ƒæµ‹è¯•**
   - å†…å­˜æ± æµ‹è¯•
   - ç¡¬ä»¶é€‚é…å™¨ Mock æµ‹è¯•

### é˜¶æ®µ 2: æ•°æ®é‡‡é›†é‡æ„ (3-4 å‘¨)

**ç›®æ ‡**: å®ç°æ’ä»¶åŒ–æ•°æ®é‡‡é›†ç®¡é“

#### ä»»åŠ¡:
1. âœ… **å®ç°é‡‡é›†ç­–ç•¥**
   - `FixedRateStrategy`
   - `TriggerBasedStrategy`
   - `AdaptiveRateStrategy`

2. âœ… **å®ç°æ•°æ®å¤„ç†å™¨**
   - `DataValidationProcessor`
   - `DataTransformProcessor`
   - `DataAggregationProcessor`

3. âœ… **å®ç°èƒŒå‹ç­–ç•¥**
   - `DropOldestStrategy`
   - `SamplingStrategy`
   - `ThrottleStrategy`

4. âœ… **å®ç°æ•°æ®é‡‡é›†ç®¡é“**
   - `DataAcquisitionPipelineBuilder`
   - `DataAcquisitionPipeline`

5. âœ… **é›†æˆæµ‹è¯•**
   - é«˜é€Ÿé‡‡é›†æµ‹è¯• (10kHz+)
   - èƒŒå‹æµ‹è¯•
   - æ€§èƒ½åŸºå‡†æµ‹è¯•

### é˜¶æ®µ 3: å‘½ä»¤æ‰§è¡Œé‡æ„ (3-4 å‘¨)

**ç›®æ ‡**: å®ç°å¯é çš„å‘½ä»¤æ‰§è¡Œæ¡†æ¶

#### ä»»åŠ¡:
1. âœ… **å®ç°å‘½ä»¤æ¨¡å¼**
   - `ICommand` æ¥å£
   - å…·ä½“å‘½ä»¤ç±» (`StaticControlCommand`, `DynamicControlCommand`, etc.)

2. âœ… **å®ç°å‘½ä»¤é˜Ÿåˆ—** (`CommandQueue`)
   - ä¼˜å…ˆçº§é˜Ÿåˆ—
   - çº¿ç¨‹å®‰å…¨

3. âœ… **å®ç°å‘½ä»¤æ‰§è¡Œå™¨** (`CommandExecutor`)
   - é‡è¯•æœºåˆ¶
   - è¶…æ—¶å¤„ç†
   - ç†”æ–­å™¨

4. âœ… **å®ç°å‘½ä»¤çŠ¶æ€ç®¡ç†** (`CommandStateManager`)
   - çŠ¶æ€è¿½è¸ª
   - äº‹ä»¶å‘å¸ƒ

5. âœ… **é›†æˆæµ‹è¯•**
   - å‘½ä»¤é˜Ÿåˆ—æµ‹è¯•
   - é‡è¯•å’Œè¶…æ—¶æµ‹è¯•
   - å¹¶å‘æµ‹è¯•

### é˜¶æ®µ 4: æ§åˆ¶ç­–ç•¥æ‰©å±• (2-3 å‘¨)

**ç›®æ ‡**: å®ç°å¯æ’æ‹”æ§åˆ¶ç­–ç•¥

#### ä»»åŠ¡:
1. âœ… **å®ç°ç­–ç•¥æ¥å£** (`IControlStrategy`)

2. âœ… **å®ç°åŸºç¡€ç­–ç•¥**
   - `StaticControlStrategy`
   - `DynamicControlStrategy`

3. âœ… **å®ç°é«˜çº§ç­–ç•¥**
   - `PIDControlStrategy`
   - `FuzzyControlStrategy` (å¯é€‰)

4. âœ… **é›†æˆæµ‹è¯•**

### é˜¶æ®µ 5: æœåŠ¡ç¼–æ’ (2 å‘¨)

**ç›®æ ‡**: å®ç°å¤šæ§åˆ¶å™¨åè°ƒ

#### ä»»åŠ¡:
1. âœ… **å®ç°æ§åˆ¶å™¨ç¼–æ’å™¨** (`ControllerOrchestrator`)

2. âœ… **å®ç°äº‹ä»¶æ€»çº¿** (`IEventBus`)

3. âœ… **é›†æˆåˆ°ç°æœ‰ç³»ç»Ÿ**
   - æ›´æ–° `ControllerService`
   - æ›´æ–° DI å®¹å™¨æ³¨å†Œ

### é˜¶æ®µ 6: åŸºç¡€è®¾æ–½å®Œå–„ (2-3 å‘¨)

**ç›®æ ‡**: å¢å¼ºå¯è§‚æµ‹æ€§å’Œé…ç½®ç®¡ç†

#### ä»»åŠ¡:
1. âœ… **å®ç°æŒ‡æ ‡é‡‡é›†** (`MetricsCollector`)
   - æ•°æ®é‡‡é›†é€Ÿç‡
   - å‘½ä»¤æ‰§è¡ŒæˆåŠŸç‡
   - ç¡¬ä»¶è¿æ¥çŠ¶æ€

2. âœ… **å®ç°ç»“æ„åŒ–æ—¥å¿—**
   - Serilog é…ç½®
   - ä¸Šä¸‹æ–‡ä¿¡æ¯

3. âœ… **å®ç°é…ç½®ç®¡ç†** (`ConfigurationManager`)
   - ç¯å¢ƒé…ç½®
   - çƒ­é‡è½½

4. âœ… **å®ç°å¥åº·ç›‘æ§** (`HardwareHealthMonitor`)
   - å®šæœŸå¥åº·æ£€æŸ¥
   - å‘Šè­¦æœºåˆ¶

### é˜¶æ®µ 7: è¿ç§»å’Œéƒ¨ç½² (3-4 å‘¨)

**ç›®æ ‡**: å¹³æ»‘è¿ç§»åˆ°æ–°æ¶æ„

#### ä»»åŠ¡:
1. âœ… **å®ç°å…¼å®¹å±‚**
   - æ—§æ¥å£é€‚é…å™¨
   - æ¸è¿›å¼è¿ç§»

2. âœ… **ç«¯åˆ°ç«¯æµ‹è¯•**
   - å®Œæ•´å·¥ä½œæµæµ‹è¯•
   - å›å½’æµ‹è¯•

3. âœ… **æ€§èƒ½è°ƒä¼˜**
   - å†…å­˜ä¼˜åŒ–
   - çº¿ç¨‹ä¼˜åŒ–

4. âœ… **æ–‡æ¡£ç¼–å†™**
   - æ¶æ„æ–‡æ¡£
   - API æ–‡æ¡£
   - è¿ç§»æŒ‡å—

---

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ä¼˜åŒ–

#### ç­–ç•¥:
- **å¯¹è±¡æ± åŒ–**: ä½¿ç”¨ `OptimizedMemoryPool` å¤ç”¨ç¼“å†²åŒº
- **RAII æ¨¡å¼**: `PooledBuffer` è‡ªåŠ¨å½’è¿˜,é¿å…æ³„æ¼
- **åˆ†çº§ç¼“å†²**: æ ¹æ®å¤§å°åˆ†é…ä¸åŒå°ºå¯¸çš„ç¼“å†²åŒº
- **é™åˆ¶æ± å¤§å°**: é˜²æ­¢å†…å­˜æ— é™å¢é•¿

#### é¢„æœŸæ”¶ç›Š:
- å‡å°‘ GC å‹åŠ›: **~70%**
- å‡å°‘å†…å­˜åˆ†é…: **~80%**
- é™ä½å†…å­˜ç¢ç‰‡

### 2. çº¿ç¨‹ä¼˜åŒ–

#### ç­–ç•¥:
- **ä¸“ç”¨é«˜ä¼˜å…ˆçº§çº¿ç¨‹**: æ•°æ®é‡‡é›†ä½¿ç”¨ `EventLoopScheduler`
- **ä»»åŠ¡æ± **: å‘½ä»¤æ‰§è¡Œä½¿ç”¨ `Task.Run` (çº¿ç¨‹æ± )
- **å¼‚æ­¥ I/O**: æ‰€æœ‰ç¡¬ä»¶æ“ä½œå¼‚æ­¥åŒ–
- **æ— é”æ•°æ®ç»“æ„**: ä½¿ç”¨ `ConcurrentDictionary`, `ConcurrentBag`

#### é¢„æœŸæ”¶ç›Š:
- é™ä½çº¿ç¨‹åˆ‡æ¢å¼€é”€: **~50%**
- æé«˜å“åº”æ€§: **~30%**

### 3. æ•°æ®æµä¼˜åŒ–

#### ç­–ç•¥:
- **èƒŒå‹æ§åˆ¶**: ä½¿ç”¨ `IBackpressureStrategy` é˜²æ­¢è¿‡è½½
- **æ‰¹å¤„ç†**: å‡å°‘äº‹ä»¶é¢‘ç‡
- **å¤šæ’­**: ä½¿ç”¨ `Publish().RefCount()` é¿å…é‡å¤è®¡ç®—
- **å»¶è¿ŸåŠ è½½**: æŒ‰éœ€è®¢é˜…æ•°æ®æµ

#### é¢„æœŸæ”¶ç›Š:
- é™ä½ CPU ä½¿ç”¨ç‡: **~40%**
- æé«˜ååé‡: **~60%**

### 4. å‘½ä»¤æ‰§è¡Œä¼˜åŒ–

#### ç­–ç•¥:
- **ä¼˜å…ˆçº§é˜Ÿåˆ—**: ç´§æ€¥å‘½ä»¤ä¼˜å…ˆæ‰§è¡Œ
- **æ‰¹é‡æ“ä½œ**: åˆå¹¶ç›¸ä¼¼å‘½ä»¤
- **æ™ºèƒ½é‡è¯•**: æŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨
- **ç†”æ–­å™¨**: å¿«é€Ÿå¤±è´¥,é¿å…çº§è”æ•…éšœ

#### é¢„æœŸæ”¶ç›Š:
- é™ä½å‘½ä»¤å»¶è¿Ÿ: **~50%**
- æé«˜æˆåŠŸç‡: **~20%**

---

## ğŸ” å…³é”®æŠ€æœ¯å†³ç­–

### 1. ä¸ºä»€ä¹ˆä½¿ç”¨å‘½ä»¤æ¨¡å¼?

**ä¼˜ç‚¹**:
- âœ… è§£è€¦å‘½ä»¤å‘é€è€…å’Œæ‰§è¡Œè€…
- âœ… æ”¯æŒå‘½ä»¤æ’é˜Ÿã€æ’¤é”€ã€é‡åš
- âœ… æ˜“äºæ·»åŠ æ–°å‘½ä»¤ç±»å‹
- âœ… ä¾¿äºæ—¥å¿—è®°å½•å’Œå®¡è®¡

**ç¼ºç‚¹**:
- âŒ å¢åŠ ç±»çš„æ•°é‡
- âŒ ç•¥å¾®å¢åŠ å¤æ‚åº¦

**å†³ç­–**: ä¼˜ç‚¹è¿œå¤§äºç¼ºç‚¹,é‡‡ç”¨å‘½ä»¤æ¨¡å¼

### 2. ä¸ºä»€ä¹ˆä½¿ç”¨ Rx.NET?

**ä¼˜ç‚¹**:
- âœ… åŸæœ‰ç³»ç»Ÿå·²ä½¿ç”¨ Rx.NET
- âœ… å¼ºå¤§çš„å¼‚æ­¥æ•°æ®æµå¤„ç†èƒ½åŠ›
- âœ… ä¸°å¯Œçš„æ“ä½œç¬¦ (Buffer, Throttle, Sample, etc.)
- âœ… æ˜“äºç»„åˆå’Œæµ‹è¯•

**ç¼ºç‚¹**:
- âŒ å­¦ä¹ æ›²çº¿é™¡å³­
- âŒ è°ƒè¯•å›°éš¾

**å†³ç­–**: ç»§ç»­ä½¿ç”¨ Rx.NET,ä½†å¢åŠ æ›´å¤šæŠ½è±¡å±‚

### 3. ä¸ºä»€ä¹ˆä½¿ç”¨æ’ä»¶åŒ–æ¶æ„?

**ä¼˜ç‚¹**:
- âœ… æ˜“äºæ‰©å±• (æ·»åŠ æ–°ç­–ç•¥æ— éœ€ä¿®æ”¹æ ¸å¿ƒ)
- âœ… æé«˜å¯æµ‹è¯•æ€§ (å¯ä»¥ Mock å„ä¸ªç»„ä»¶)
- âœ… æ”¯æŒè¿è¡Œæ—¶é…ç½®

**ç¼ºç‚¹**:
- âŒ å¢åŠ åˆå§‹å¼€å‘æˆæœ¬
- âŒ å¢åŠ æŠ½è±¡å±‚

**å†³ç­–**: é•¿æœŸæ”¶ç›Šå¤§äºçŸ­æœŸæˆæœ¬,é‡‡ç”¨æ’ä»¶åŒ–æ¶æ„

---

## ğŸ“ é…ç½®ç¤ºä¾‹

### appsettings.json

```json
{
  "AppSettings": {
    "AppName": "åˆ†å¸ƒå¼å¤šé€šé“æ§åˆ¶å™¨",
    "Version": "2.0.0",
    "IsDebug": true,
    "IsMock": false
  },
  "DataAcquisition": {
    "Strategy": "FixedRate",
    "SampleRate": 10000,
    "BufferSize": 5000,
    "BackpressureStrategy": "DropOldest",
    "ThreadPriority": "Highest"
  },
  "CommandExecution": {
    "MaxRetryCount": 3,
    "InitialRetryDelayMs": 100,
    "CommandTimeoutMs": 5000,
    "EnableCircuitBreaker": true,
    "CircuitBreakerThreshold": 5
  },
  "MemoryPool": {
    "StandardSizes": [1024, 4096, 16384, 65536, 1048576],
    "MaxPoolSize": 100
  },
  "HealthCheck": {
    "Interval": 3000,
    "Timeout": 1000
  },
  "Logging": {
    "MinimumLevel": "Information",
    "FilePath": "logs/mccs-.log",
    "RollingInterval": "Day"
  }
}
```

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

**è¦†ç›–ç‡ç›®æ ‡**: > 80%

**å…³é”®æµ‹è¯•**:
- å†…å­˜æ± æµ‹è¯•
- å‘½ä»¤é˜Ÿåˆ—æµ‹è¯•
- å‘½ä»¤æ‰§è¡Œå™¨æµ‹è¯•
- æ•°æ®å¤„ç†å™¨æµ‹è¯•

### é›†æˆæµ‹è¯•

**å…³é”®åœºæ™¯**:
- æ•°æ®é‡‡é›†ç®¡é“ç«¯åˆ°ç«¯æµ‹è¯•
- å‘½ä»¤æ‰§è¡Œç®¡é“ç«¯åˆ°ç«¯æµ‹è¯•
- å¤šæ§åˆ¶å™¨åè°ƒæµ‹è¯•

### æ€§èƒ½æµ‹è¯•

**åŸºå‡†æµ‹è¯•**:
- 10kHz é‡‡æ ·ç‡ä¸‹çš„ CPU/å†…å­˜ä½¿ç”¨ç‡
- 1000 å‘½ä»¤/ç§’ä¸‹çš„å‘½ä»¤å»¶è¿Ÿå’Œååé‡
- é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§æµ‹è¯• (24 å°æ—¶+)

### å‹åŠ›æµ‹è¯•

**åœºæ™¯**:
- æœ€å¤§é‡‡æ ·ç‡æµ‹è¯•
- å‘½ä»¤é˜Ÿåˆ—æº¢å‡ºæµ‹è¯•
- ç¡¬ä»¶è¿æ¥å¤±è´¥æ¢å¤æµ‹è¯•

---

## ğŸ¯ æ€»ç»“

### æ–°æ¶æ„çš„æ ¸å¿ƒä¼˜åŠ¿

1. **é«˜æ€§èƒ½**
   - ä¼˜åŒ–çš„å†…å­˜ç®¡ç† (æ± åŒ–ã€RAII)
   - é«˜æ•ˆçš„çº¿ç¨‹æ¨¡å‹ (ä¸“ç”¨é«˜ä¼˜å…ˆçº§çº¿ç¨‹)
   - æ™ºèƒ½çš„èƒŒå‹æ§åˆ¶

2. **é«˜æ‰©å±•æ€§**
   - æ’ä»¶åŒ–é‡‡é›†ç­–ç•¥
   - å‘½ä»¤æ¨¡å¼
   - ç­–ç•¥æ¨¡å¼

3. **é«˜å¯é æ€§**
   - å®Œå–„çš„é”™è¯¯å¤„ç†
   - é‡è¯•å’Œç†”æ–­æœºåˆ¶
   - å¥åº·ç›‘æ§

4. **æ˜“ç»´æŠ¤**
   - æ¸…æ™°çš„åˆ†å±‚
   - å•ä¸€èŒè´£
   - ä¾èµ–å€’ç½®

5. **å¯è§‚æµ‹æ€§**
   - ç»“æ„åŒ–æ—¥å¿—
   - æŒ‡æ ‡é‡‡é›†
   - å‘½ä»¤è¿½è¸ª

### æŠ•èµ„å›æŠ¥åˆ†æ

**åˆæœŸæŠ•èµ„**:
- å¼€å‘æ—¶é—´: 20-25 å‘¨
- æµ‹è¯•æ—¶é—´: 5-7 å‘¨
- è¿ç§»æ—¶é—´: 3-4 å‘¨

**é•¿æœŸæ”¶ç›Š**:
- å‡å°‘ bug: **~60%**
- æé«˜æ€§èƒ½: **~50%**
- åŠ å¿«æ–°åŠŸèƒ½å¼€å‘: **~40%**
- é™ä½ç»´æŠ¤æˆæœ¬: **~50%**

---

## ğŸ“ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **è¯„å®¡æœ¬æ–¹æ¡ˆ**: ä¸å›¢é˜Ÿè®¨è®º,æ”¶é›†åé¦ˆ
2. **åˆ¶å®šè¯¦ç»†è®¡åˆ’**: åˆ†é…èµ„æº,è®¾ç½®é‡Œç¨‹ç¢‘
3. **å¼€å§‹é˜¶æ®µ 1**: ä¿®å¤å…³é”® bug,å»ºç«‹åŸºç¡€
4. **æŒç»­è¿­ä»£**: æŒ‰é˜¶æ®µé€æ­¥å®ç°æ–°æ¶æ„
5. **å¹³æ»‘è¿ç§»**: ä¿æŒå‘åå…¼å®¹,æ¸è¿›å¼æ›¿æ¢

---

*æœ¬æ¶æ„æ–¹æ¡ˆç”± Claude AI ç”Ÿæˆï¼Œæ—¥æœŸ: 2025-11-03*
